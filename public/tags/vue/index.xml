<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vue on 子舒的博客</title>
    <link>https://blog.zburu.com/tags/vue/</link>
    <description>Recent content in vue on 子舒的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 29 Mar 2022 13:08:00 +0000</lastBuildDate><atom:link href="https://blog.zburu.com/tags/vue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在vue中制作canvas波浪图</title>
      <link>https://blog.zburu.com/posts/111.html/</link>
      <pubDate>Tue, 29 Mar 2022 13:08:00 +0000</pubDate>
      
      <guid>https://blog.zburu.com/posts/111.html/</guid>
      <description>新建组件 Canvas.vue 。
// @/components/Canvas.vue &amp;lt;template&amp;gt; &amp;lt;div :style=&amp;#34;{ height: waveAllHeight + &amp;#39;px&amp;#39;, background: bgColor }&amp;#34; class=&amp;#34;wave&amp;#34;&amp;gt; &amp;lt;canvas id=&amp;#34;wave1&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;canvas id=&amp;#34;wave2&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;canvas id=&amp;#34;wave3&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { name: &amp;#34;Canvas&amp;#34;, props: { bgColor: { default: &amp;#34;none&amp;#34;, }, // 背景色 waveAllHeight: { default: 160 }, // 波浪的整体高度 waveCount: { default: 2 }, // 波峰个数 waveHeight: { default: 50 }, // 波浪起伏高度 // 波浪颜色 waveColor: { default () { return [ &amp;#34;#f3f3f3&amp;#34;, &amp;#34;#f3f3f3&amp;#34;, &amp;#34;#f3f3f3&amp;#34;, ]; }, }, // 波浪速率 waveTime: { default () { return [4000, 4000, 4000]; }, }, }, data () { return {}; }, mounted () { this.wavePlay(&amp;#34;wave1&amp;#34;, 140, this.waveColor[0], this.waveTime[0]); this.wavePlay(&amp;#34;wave2&amp;#34;, 140, this.waveColor[1], this.waveTime[1]); this.wavePlay(&amp;#34;wave3&amp;#34;, 140, this.waveColor[2], this.waveTime[2]); }, methods: { wavePlay ($canvasID, $progress, $maveColor, $time) { const that = this; let waveWidth = 3300, // 波浪长度 offset = 0, waveHeight = that.waveHeight, // 波浪起伏高度 waveCount = that.waveCount, // 波浪个数 startX = -1200, startY = 212, // canvas 高度 progress = $progress, // 波浪位置高度 d2 = waveWidth / waveCount, // 单个波浪的宽度 d = d2 / 2, hd = d / 2, c = document.</description>
    </item>
    
    <item>
      <title>在 vue 中使用 axios 调用数据</title>
      <link>https://blog.zburu.com/posts/71.html/</link>
      <pubDate>Tue, 08 Jun 2021 21:02:00 +0000</pubDate>
      
      <guid>https://blog.zburu.com/posts/71.html/</guid>
      <description>如何在 vue 中完成一次接口的调用？首选就是 axios，方便快捷又好用，支持各种 api ,封装也很方便。
先用 node 安装一下。
npm install axios 然后在 main.js 文件中引入。
import axios from &amp;#39;axios&amp;#39; import VueAxios from &amp;#39;vue-axios&amp;#39; Vue.use(VueAxios, axios) 以我的一个工程目录作为实例，看一下代码。
// ListThere.vue // html 代码 ... &amp;lt;div&amp;gt;{{ info }}&amp;lt;/div&amp;gt; ... // js 代码 import axios from &amp;#34;axios&amp;#34;; export default { name: &amp;#34;ListThere&amp;#34;, data() { return { ... }; }, components: { ... }, methods: { ... }, mounted() { axios .get(&amp;#34;http://api.h-camel.com/api?mod=interview&amp;amp;ctr=issues&amp;amp;act=today&amp;#34;) .then((response) =&amp;gt; (this.info = response)) }, }; 数据成功的被取到，然后需要将它在页面中展示出来。使用 vue 自带的 v-for 列表渲染。
&amp;lt;ul class=&amp;#34;list-api-show&amp;#34;&amp;gt; &amp;lt;li v-for=&amp;#34;(item, index) in show&amp;#34; :key=&amp;#34;index&amp;#34;&amp;gt; {{ item.title }} &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 然后通过 axios 把数据指向 v-for.
mounted() { axios // ... .then((response) =&amp;gt; (this.show = response.data.result.today)) } 数据成功取出然后展示在 v-for 里面。
当然了，这是成功的情况，加入失败了呢？我们需要浏览器给出提示，所以 axios 给出了一个 api &amp;mdash; err 语法。
mounted() { axios // ... .catch(function (error) { if (error.response) { console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); console.log(&amp;#39;err&amp;#39;) } else if (error.request) { console.log(error.request); console.log(&amp;#39;err&amp;#39;) } else { console.</description>
    </item>
    
    <item>
      <title>使用 React 与 Vue 创建同一款 App，差别究竟有多大？</title>
      <link>https://blog.zburu.com/posts/43.html/</link>
      <pubDate>Wed, 06 Jan 2021 20:47:00 +0000</pubDate>
      
      <guid>https://blog.zburu.com/posts/43.html/</guid>
      <description>关于 React 框架 和 Vue 框架 的对比，用两者写出同一个程序，对比其代码实现的过程，看看它们的差异究竟有多大？
转载于：https://blog.csdn.net/csdnnews/article/details/81880378 原文：https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd 作者简介：Sunil Sandhu，一位 Web 全栈工程师 + 空想家。 译者：安翔，责编：屠敏
众所周知，Vue 和 React 都是目前非常著名的前端框架。我在工作中经常使用 Vue，因此我对它有很深入的了解。同时，我也对 React 充满了好奇，想要学习一下，一探究竟。
于是我阅读了 React 文档并观看了一些视频教程，虽然这些资料很不错，但是我真正想了解的是 React 与 Vue 之间的不同之处。所谓“不同之处”，我并非想知道它们是否都具有虚拟 DOMS 或者它们如何渲染页面，而是希望有人能够从代码的角度解释这两者之间的差异。我想找到一篇解释这些差异的文章，以便 Vue 或者 React 的初学者可以更好地理解它们两者之间的差异。
很遗憾，我并未找到一篇这样的文章。于是我意识到必须自己动手来比较 Vue 与 React 之间的异同。在我自力更生的过程中，我用这篇文章记录下了具体过程。
1.目标 我将会构建一个标准的待办事项应用程序，允许用户添加和删除列表中的项目。这两个应用程序都使用默认的 CLI（command-line interface，命令行界面） 构建，React 使用 create-react-app，Vue 使用 vue-cli。
两个应用程序的外观如下：
两个应用程序的 CSS 代码几乎一样，但这些代码的位置存在差异。考虑到这一点，我们来看看这两个应用程序的文件结构：
你会发现它们的结构几乎完全相同。唯一的区别在于 React App 拥有三个 CSS 文件，而 Vue App 中没有 CSS 文件。这是因为 React 的 create-react-app 组件需要一个附带文件来保存其样式，而 Vue CLI 采用全包方法，其样式在实际组件文件中声明。
两种不同的策略得到的结果是一样的，相信开发者很快能够掌握这两种不同的策略。开发者可以根据自己的偏好做出选择，你会听到开发社区关于如何构建 CSS 的大量讨论。以上，我们遵循两个 CLI 列出了代码结构。
在我们进一步讨论之前，先快速看一下典型的 Vue 和 React 组件的外观：
现在让我们正式开始，深入其中的细节！
2.如何修改数据 首先，我们需要明白“修改数据”的意思是什么。它听起来有些学术，但实际上很简单，就是把我们已经存储好的数据进行更改。比如，如果我们想把一个人的名字变量从“Jhon”改为“Mark”，我们就需要执行“修改数据”的操作。在这一点上，React 和 Vue 的处理方式有所区别。Vue 本质上会创建一个数据对象，其中的数据可以自由更改；React 则创建一个状态对象，更改数据需要一些额外的操作。React 之所以需要额外的操作有着自己的理由，稍后我会深入介绍。在此之前，我们先看看 Vue 中的数据对象和 React 中的状态对象：
vue 数据对象 React 状态对象 从图中可以看出，我们传入了相同的数据，但它们的标记方法不同。因此，将初始数据传递到组件的方式非常相似。但正如我们提到的那样，在两个框架中更改数据的方式有所不同。
假设我们有一个名为 name: ‘Sunil’ 的数据元素。
在 Vue 中，我们通过调用 this.name 来引用它。我们也可以通过调用 this.name =&amp;lsquo;John&amp;rsquo; 来更新它。这样一来，名字就被成功改为了 “Jhon”。
在 React 中，我们通过调用 this.state.name 来引用同一段数据。现在关键的区别在于，我们不能简单地写成 this.state.name =&amp;lsquo;John&amp;rsquo;，因为 React 有限制机制，它会阻止这种简单的修改方式。在 React 中，我们需要这样写：this.setState({name：&amp;lsquo;John&amp;rsquo;})。
虽然这基本上与我们在 Vue 中实现的结果一样，但是 React 的操作更为繁琐，那是因为 Vue 在每次更新数据时默认组合了自己的 setState 版本。 简单来说就是，React 需要 setState，然后更新其内部数据，而对于 Vue 来说，当你更新数据对象的值时它就默认了你的更改意图。 那么为什么 React 没有进行简化，为什么需要 setState 呢？ Revanth Kumar 对此做出了解释：</description>
    </item>
    
    <item>
      <title>vue学习笔记(3)－－computed, watch，calss, style</title>
      <link>https://blog.zburu.com/posts/29.html/</link>
      <pubDate>Wed, 25 Nov 2020 13:05:00 +0000</pubDate>
      
      <guid>https://blog.zburu.com/posts/29.html/</guid>
      <description>一、计算属性computed 1.例子 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;{{revermessage}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39; }, computed: { revermessage: function() { return this.message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;) } } }) &amp;lt;/script&amp;gt; 声明一个计算属性severmessage，在computed中被指向对message进行一些方法操作后的返回值
此时vm.severmessage依赖于vm.message的变化，对message改变数据，会引起severmessage的更新
2.计算属性缓存和方法 还可以通过在表达式中调用方法来达到想要的效果
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;{{revermessage()}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39; }, methods: { revermessage: function() { return this.message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;) } } }) &amp;lt;/script&amp;gt; 经过测试，两者的结果是一样的
我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的
区别是：计算属性是基于他们的响应式依赖进行缓存的，只有当响应式依赖，也就是message发生改变时才会重新求值，就意味着，只要message还没改变，多次访问revermessage计算属性只会返回之前计算结果的缓存，而不是直接执行计算属性的函数
而方法，在每次触发重新渲染时，调用方法都会执行一次函数，这就多了一份开销
我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代
3.计算属性和侦听属性 vue还有一种方式来观测vue实例上的数据变动：侦听属性－－watch
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; {{fullname}} &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { firstname: &amp;#39;a&amp;#39;, lastname: &amp;#39;b&amp;#39;, fullname: &amp;#39;ab&amp;#39; }, watch: { firstname: function(val) { this.fullName = val + &amp;#39; &amp;#39; + this.lastName }, lastname: function(val) { this.fullName = this.firstName + &amp;#39; &amp;#39; + val } } }) &amp;lt;/script&amp;gt; 使用过程是极其繁琐且重复的，再来用计算属性试一下
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; {{fullname}} &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { firstname: &amp;#39;a&amp;#39;, lastname: &amp;#39;b&amp;#39; }, computed: { fullname: function() { return this.</description>
    </item>
    
    <item>
      <title>vue学习笔记(2)－－vue实例和模板语法</title>
      <link>https://blog.zburu.com/posts/28.html/</link>
      <pubDate>Tue, 24 Nov 2020 13:05:00 +0000</pubDate>
      
      <guid>https://blog.zburu.com/posts/28.html/</guid>
      <description>一、vue实例 1.创建vue实例 一个vue实例应该通过new Vue来创建根实例，所有的 vue 组件其实都是 vue 实例
var vm = new Vue({ ... }) 当一个实例被创建时，data对象中的 property 都被加入到vue的响应式系统中，当值发生改变时，试图也会改变
var data = {a: 1} var vm = new Vue({ data: data }) 此时在控制台输入vm.a == data.a会返回true，变量data已经被赋给vue实例中的data对象了
同时，对两个对象的数据进行操作改变也会影响到另一个
vm.a = 2 // data.a = 2 data.a = 3 // vm.a = 3 当数据改变时，视图也会重新渲染，如果在vue实例被创建后，又添加了一个新的property，则不会被加入到响应式系统中
如果一开始就知道后面会添加一个property，但是一开始不存在或为空，需要设置一些初始值
data: { newTodoText: &amp;#39;&amp;#39;, visitCount: 0, hideCompletedTods: fasle, todos: [], error: null } 使用Object.freeze()方法的时候，无法修改数据引起视图变化
Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var data = {message: &amp;#39;hello,wolrd&amp;#39;} Object.freeze(data) var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: data }) &amp;lt;/script&amp;gt; 在控制台改变vm.message的值会直接报错，因为data对象已经被冻结了，不可改变
vm.$data
代表vue实例观察的数据对象
console.log(vm.$data) // 返回数据对象的数组形式 var data = { a: 1 } var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: data }) vm.$data === data // true vm.$el === document.getElementById(&amp;#39;app&amp;#39;) // true 2.生命周期函数 每个实例在被创建的时候，都要经历一些初始化过程，比如：设置数据监听，编译模板，将实例挂载到dom，更新dom等
在这个过程中会运行一些叫做生命周期的钩子函数，可以在不同阶段添加自己需要的代码
比如created钩子可以用来表示一个实例被创建之后执行的代码
new Vue({ data: { a: 1 }, created: function () { console.log(&amp;#39;a is: &amp;#39; + this.</description>
    </item>
    
    <item>
      <title>vue学习笔记(1)－－什么是vue?</title>
      <link>https://blog.zburu.com/posts/27.html/</link>
      <pubDate>Mon, 23 Nov 2020 13:04:00 +0000</pubDate>
      
      <guid>https://blog.zburu.com/posts/27.html/</guid>
      <description>一、什么是vue? 练习时使用，最新版本
&amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 生产时使用，明确版本号的版本，避免造成不可预见的问题
&amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue@2.6.12&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; hello world
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; {{message}} &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { message: &amp;#39;hello,world&amp;#39; } }) &amp;lt;/script&amp;gt; 1.v-指令 v-bind－－绑定属性 &amp;lt;div id=&amp;#34;app-2&amp;#34;&amp;gt; &amp;lt;span v-bind:title=&amp;#34;message&amp;#34;&amp;gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;页面加载于 &amp;#39; + new Date().toLocaleString() } }) &amp;lt;/script&amp;gt; v-bind是vue特有的提供的属性，他会在dom上应用一个响应式的操作
打开console，输入app.message = &amp;quot;hello&amp;quot;，页面会改变内容只显示hello
又或者输入app.message = false，内容会直接不显示
vue官网例子：
&amp;lt;!-- 绑定一个 attribute --&amp;gt; &amp;lt;img v-bind:src=&amp;#34;imageSrc&amp;#34;&amp;gt; &amp;lt;!-- 动态 attribute 名 (2.6.0+) --&amp;gt; &amp;lt;button v-bind:[key]=&amp;#34;value&amp;#34;&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;!-- 缩写 --&amp;gt; &amp;lt;img :src=&amp;#34;imageSrc&amp;#34;&amp;gt; &amp;lt;!-- 动态 attribute 名缩写 (2.6.0+) --&amp;gt; &amp;lt;button :[key]=&amp;#34;value&amp;#34;&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;!-- 内联字符串拼接 --&amp;gt; &amp;lt;img :src=&amp;#34;&amp;#39;/path/to/images/&amp;#39; + fileName&amp;#34;&amp;gt; &amp;lt;!-- class 绑定 --&amp;gt; &amp;lt;div :class=&amp;#34;{ red: isRed }&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :class=&amp;#34;[classA, classB]&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :class=&amp;#34;[classA, { classB: isB, classC: isC }]&amp;#34;&amp;gt; &amp;lt;!-- style 绑定 --&amp;gt; &amp;lt;div :style=&amp;#34;{ fontSize: size + &amp;#39;px&amp;#39; }&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :style=&amp;#34;[styleObjectA, styleObjectB]&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- 绑定一个全是 attribute 的对象 --&amp;gt; &amp;lt;div v-bind=&amp;#34;{ id: someProp, &amp;#39;other-attr&amp;#39;: otherProp }&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>vue使用cli脚手架构建项目工程</title>
      <link>https://blog.zburu.com/posts/24.html/</link>
      <pubDate>Fri, 20 Nov 2020 13:03:00 +0000</pubDate>
      
      <guid>https://blog.zburu.com/posts/24.html/</guid>
      <description>vue使用cli脚手架构建项目工程，执行的命令以及遇到的相关的问题
1.下载安装node 测试一下是否成功安装，
$ node -v // 返回下载的版本号 2.安装webpack环境 $ npm install webpack -g // 如果失败，可能是因为用户没有权限 // 使用下面这种，管理员权限 $ sudo npm install webpack -g 如果返回版本号代表成功，如果没有，则需要输入下面的命令
$ npm install webpack webpack-cli -g webpack 4.X 开始，需要安装 webpack-cli 依赖
3.全局安装vue-cli $ npm install --global vue-cli // 如果失败，使用sudo $ sudo npm install --global vue-cli 安装完成之后，输入
$ vue -V 如果返会版本号，说明安装成功
4.构建项目 前面那些命令执行完之后，就可以构建ci项目了，找到我们想要放置项目的文件夹，进入终端，cd到这个文件夹
输入命令：
$ vue init webpack vuedemo // 名字自己根据要求起,vuedemo Project name (vuedomo)： &amp;mdash;&amp;ndash;项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters） Project description (A Vue.js project)： &amp;mdash;-项目描述，也可直接点击回车，使用默认名字 Author ()： &amp;mdash;-作者，输入你的大名 Runtime + Compiler: recommended for most users 运行加编译，既然已经说了推荐，就选它了 Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere 仅运行时，已经有推荐了就选择第一个了 Install vue-router? (Y/n) 是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。 Use ESLint to lint your code? (Y/n) 是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。 接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车 Setup unit tests with Karma + Mocha?</description>
    </item>
    
    <item>
      <title>vue生命周期</title>
      <link>https://blog.zburu.com/posts/5.html/</link>
      <pubDate>Fri, 19 Jun 2020 21:07:00 +0000</pubDate>
      
      <guid>https://blog.zburu.com/posts/5.html/</guid>
      <description>学习vue中一个非常重要的领域，就是生命周期，它包含了很多的内容。每个vue实例在被创建的时候都要经历一系列的初始化过程，这个过程就是vue的生命周期。
每个vue实例在被创建的时候都要经过一系列的初始化过程——例如，需要把设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等，我们要把这一系列的过程称为组件的生命周期（组件从注册到销毁的整个过程）。我们有时候需要在组件生命周期的某个过程中，执行某些代码，基于此，vue提供了生命周期钩子函数，给了用户在不同阶段添加自己的代码的机会。
但是在此之前，我们要详细的介绍下组件的生命周期，以及生命后期中每个阶段组件完成和未完成的部分。
一、组件的生命周期 放一张大家都很熟悉的官网文章中对生命周期的注释图。
从图中可以看出，vue为生命周期提供了8个钩子函数，分别是：
beforeCreate: 创建前 created: 创建后 beforeMount: 挂载前 mounted: 挂载后 beforeUpate: 更新前 upated: 更新后 beforeDestoy: 销毁前 destoyed: 销毁后 1.beforeCreate beforeCreate在vue实例发生之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。
我们在上面的例子中在的beforeCreate钩子中调用Vue的data和method，来看一下结果：
可以看到Vue中的data和方法都是去不到的，并且是在wath之前执行
2.created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。
主要应用：调用数据，调用方法，调用异步函数
console输出的结果我们看一下
可以看到：created钩子可以获取Vue的data，调用Vue方法，获取原本HTML上的直接加载出来的DOM，但是无法获取到通过挂载模板生成的DOM（例如：v-for循环遍历Vue.list生成li）
3.beforeMount 在挂载开始之前被调用：相关的 render 函数（模板）首次被调用。
例如通过v-for生成的html还没有被挂载到页面上
beforeMount: function () { console.log(&amp;#39;beforeMount:&amp;#39;,document.getElementsByTagName(&amp;#39;li&amp;#39;).length); }, console打印出来的beforeMount为1
4.mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。
有初始值的DOM渲染，例如我们的初始数据list,渲染出来的li，只有这里才能获取
mounted: function () { console.log(&amp;#39;mounted:&amp;#39;,document.getElementsByTagName(&amp;#39;li&amp;#39;).length); }, 结果 mounted: 3 , 可以看到到这里为止，挂载到实例上了，我们可以获取到li的个数了
5.beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。
当我们更改Vue的任何数据，都会触发该函数
beforeUpdate: function () { console.log(&amp;#39;beforeUpdate 钩子执行.&amp;#39;); console.log(&amp;#39;beforeUpdate:&amp;#39;+this.message) }, 6.updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。
该钩子在服务器端渲染期间不被调用。
数据更新就会触发（vue所有的数据只有有更新就会触发）,如果想数据一遍就做统一的处理，可以用这个，如果想对不同数据的更新做不同的处理可以用nextTick，或者是watch进行监听
updated: function () { console.log(&amp;#39;updated 钩子执行...&amp;#39;); console.log(&amp;#39;updated:&amp;#39;,this.message) }, 7.beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。
8.destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。
结果
可以看打到销毁Vue实例时会调用这两个函数</description>
    </item>
    
  </channel>
</rss>
