<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>为什么 key 是必须的？ | 不如吃茶去</title><meta name=keywords content="react"><meta name=description content="之前有说到，在 React 中渲染列表的时候，要给每一个数据加一个 key 值，赋予一个确定的标示，而且也详细描述了如何给一个标示，方法知道了，那么为什么要这么做呢？
在 React 中如何渲染列表？
在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。
在子元素列表末尾新增元素时，更新开销比较小。比如：
<ul> <li>first</li> <li>second</li> </ul> <ul> <li>first</li> <li>second</li> <li>third</li> </ul> React 会先匹配两个 <li>first</li> 对应的树，然后匹配第二个元素 <li>second</li> 对应的树，最后插入第三个元素的 <li>third</li> 树。
如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：
<ul> <li>Duke</li> <li>Villanova</li> </ul> <ul> <li>Connecticut</li> <li>Duke</li> <li>Villanova</li> </ul> React 不会意识到应该保留 <li>Duke</li> 和 <li>Villanova</li>，而是会重建每一个子元素 。这种情况会带来性能问题。
key
为了解决上述问题， React 支持 key 属性，当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下例子在新增 key 之后使得之前的低效转换变得高效：
<ul> <li key=&#34;1&#34;>Duke</li> <li key=&#34;2&#34;>Villanova</li> </ul> <ul> <li key=&#34;0&#34;>Connecticut</li> <li key=&#34;1&#34;>Duke</li> <li key=&#34;2&#34;>Villanova</li> </ul> 现在 React 知道只有带着 '0' key 的元素是新元素，带着 '1' 以及 '2' key 的元素仅仅移动了。"><meta name=author content="Me"><link rel=canonical href=https://zburu-hugo.vercel.app/posts/2021-01-01-%E4%B8%BA%E4%BB%80%E4%B9%88_key_%E6%98%AF%E5%BF%85%E9%A1%BB%E7%9A%84/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.ba440c9e3234243e74b01a794e5be1e5ed2ea2b1b088b818edcb1bc5edd382fa.css integrity="sha256-ukQMnjI0JD50sBp5Tlvh5e0uorGwiLgY7csbxe3Tgvo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://img.zburu.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://img.zburu.com/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://img.zburu.com/favicon.ico><link rel=apple-touch-icon href=https://img.zburu.com/favicon.ico><link rel=mask-icon href=https://img.zburu.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="为什么 key 是必须的？"><meta property="og:description" content="之前有说到，在 React 中渲染列表的时候，要给每一个数据加一个 key 值，赋予一个确定的标示，而且也详细描述了如何给一个标示，方法知道了，那么为什么要这么做呢？
在 React 中如何渲染列表？
在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。
在子元素列表末尾新增元素时，更新开销比较小。比如：
<ul> <li>first</li> <li>second</li> </ul> <ul> <li>first</li> <li>second</li> <li>third</li> </ul> React 会先匹配两个 <li>first</li> 对应的树，然后匹配第二个元素 <li>second</li> 对应的树，最后插入第三个元素的 <li>third</li> 树。
如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：
<ul> <li>Duke</li> <li>Villanova</li> </ul> <ul> <li>Connecticut</li> <li>Duke</li> <li>Villanova</li> </ul> React 不会意识到应该保留 <li>Duke</li> 和 <li>Villanova</li>，而是会重建每一个子元素 。这种情况会带来性能问题。
key
为了解决上述问题， React 支持 key 属性，当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下例子在新增 key 之后使得之前的低效转换变得高效：
<ul> <li key=&#34;1&#34;>Duke</li> <li key=&#34;2&#34;>Villanova</li> </ul> <ul> <li key=&#34;0&#34;>Connecticut</li> <li key=&#34;1&#34;>Duke</li> <li key=&#34;2&#34;>Villanova</li> </ul> 现在 React 知道只有带着 '0' key 的元素是新元素，带着 '1' 以及 '2' key 的元素仅仅移动了。"><meta property="og:type" content="article"><meta property="og:url" content="https://zburu-hugo.vercel.app/posts/2021-01-01-%E4%B8%BA%E4%BB%80%E4%B9%88_key_%E6%98%AF%E5%BF%85%E9%A1%BB%E7%9A%84/"><meta property="og:image" content="https://zburu-hugo.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-01T20:48:00+00:00"><meta property="article:modified_time" content="2021-01-01T20:48:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zburu-hugo.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="为什么 key 是必须的？"><meta name=twitter:description content="之前有说到，在 React 中渲染列表的时候，要给每一个数据加一个 key 值，赋予一个确定的标示，而且也详细描述了如何给一个标示，方法知道了，那么为什么要这么做呢？
在 React 中如何渲染列表？
在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。
在子元素列表末尾新增元素时，更新开销比较小。比如：
<ul> <li>first</li> <li>second</li> </ul> <ul> <li>first</li> <li>second</li> <li>third</li> </ul> React 会先匹配两个 <li>first</li> 对应的树，然后匹配第二个元素 <li>second</li> 对应的树，最后插入第三个元素的 <li>third</li> 树。
如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：
<ul> <li>Duke</li> <li>Villanova</li> </ul> <ul> <li>Connecticut</li> <li>Duke</li> <li>Villanova</li> </ul> React 不会意识到应该保留 <li>Duke</li> 和 <li>Villanova</li>，而是会重建每一个子元素 。这种情况会带来性能问题。
key
为了解决上述问题， React 支持 key 属性，当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下例子在新增 key 之后使得之前的低效转换变得高效：
<ul> <li key=&#34;1&#34;>Duke</li> <li key=&#34;2&#34;>Villanova</li> </ul> <ul> <li key=&#34;0&#34;>Connecticut</li> <li key=&#34;1&#34;>Duke</li> <li key=&#34;2&#34;>Villanova</li> </ul> 现在 React 知道只有带着 '0' key 的元素是新元素，带着 '1' 以及 '2' key 的元素仅仅移动了。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zburu-hugo.vercel.app/posts/"},{"@type":"ListItem","position":3,"name":"为什么 key 是必须的？","item":"https://zburu-hugo.vercel.app/posts/2021-01-01-%E4%B8%BA%E4%BB%80%E4%B9%88_key_%E6%98%AF%E5%BF%85%E9%A1%BB%E7%9A%84/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"为什么 key 是必须的？","name":"为什么 key 是必须的？","description":"之前有说到，在 React 中渲染列表的时候，要给每一个数据加一个 key 值，赋予一个确定的标示，而且也详细描述了如何给一个标示，方法知道了，那么为什么要这么做呢？\n在 React 中如何渲染列表？\n在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。\n在子元素列表末尾新增元素时，更新开销比较小。比如：\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;third\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; React 会先匹配两个 \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; 对应的树，然后匹配第二个元素 \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; 对应的树，最后插入第三个元素的 \u0026lt;li\u0026gt;third\u0026lt;/li\u0026gt; 树。\n如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Duke\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Villanova\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Connecticut\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Duke\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Villanova\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; React 不会意识到应该保留 \u0026lt;li\u0026gt;Duke\u0026lt;/li\u0026gt; 和 \u0026lt;li\u0026gt;Villanova\u0026lt;/li\u0026gt;，而是会重建每一个子元素 。这种情况会带来性能问题。\nkey\n为了解决上述问题， React 支持 key 属性，当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下例子在新增 key 之后使得之前的低效转换变得高效：\n\u0026lt;ul\u0026gt; \u0026lt;li key=\u0026#34;1\u0026#34;\u0026gt;Duke\u0026lt;/li\u0026gt; \u0026lt;li key=\u0026#34;2\u0026#34;\u0026gt;Villanova\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li key=\u0026#34;0\u0026#34;\u0026gt;Connecticut\u0026lt;/li\u0026gt; \u0026lt;li key=\u0026#34;1\u0026#34;\u0026gt;Duke\u0026lt;/li\u0026gt; \u0026lt;li key=\u0026#34;2\u0026#34;\u0026gt;Villanova\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 现在 React 知道只有带着 '0' key 的元素是新元素，带着 '1' 以及 '2' key 的元素仅仅移动了。","keywords":["react"],"articleBody":"之前有说到，在 React 中渲染列表的时候，要给每一个数据加一个 key 值，赋予一个确定的标示，而且也详细描述了如何给一个标示，方法知道了，那么为什么要这么做呢？\n在 React 中如何渲染列表？\n在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。\n在子元素列表末尾新增元素时，更新开销比较小。比如：\n\u003cul\u003e \u003cli\u003efirst\u003c/li\u003e \u003cli\u003esecond\u003c/li\u003e \u003c/ul\u003e \u003cul\u003e \u003cli\u003efirst\u003c/li\u003e \u003cli\u003esecond\u003c/li\u003e \u003cli\u003ethird\u003c/li\u003e \u003c/ul\u003e React 会先匹配两个 first 对应的树，然后匹配第二个元素 second 对应的树，最后插入第三个元素的 third 树。\n如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：\n\u003cul\u003e \u003cli\u003eDuke\u003c/li\u003e \u003cli\u003eVillanova\u003c/li\u003e \u003c/ul\u003e \u003cul\u003e \u003cli\u003eConnecticut\u003c/li\u003e \u003cli\u003eDuke\u003c/li\u003e \u003cli\u003eVillanova\u003c/li\u003e \u003c/ul\u003e React 不会意识到应该保留 Duke 和 Villanova，而是会重建每一个子元素 。这种情况会带来性能问题。\nkey\n为了解决上述问题， React 支持 key 属性，当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下例子在新增 key 之后使得之前的低效转换变得高效：\n\u003cul\u003e \u003cli key=\"1\"\u003eDuke\u003c/li\u003e \u003cli key=\"2\"\u003eVillanova\u003c/li\u003e \u003c/ul\u003e \u003cul\u003e \u003cli key=\"0\"\u003eConnecticut\u003c/li\u003e \u003cli key=\"1\"\u003eDuke\u003c/li\u003e \u003cli key=\"2\"\u003eVillanova\u003c/li\u003e \u003c/ul\u003e 现在 React 知道只有带着 '0' key 的元素是新元素，带着 '1' 以及 '2' key 的元素仅仅移动了。\n现实场景中，产生一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：\n\u003cli key={item.id}\u003e{item.name}\u003c/li\u003e 当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。\n最后，你也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变得慢。\n当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改导致无法预期的变动。\n","wordCount":"111","inLanguage":"en","datePublished":"2021-01-01T20:48:00Z","dateModified":"2021-01-01T20:48:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zburu-hugo.vercel.app/posts/2021-01-01-%E4%B8%BA%E4%BB%80%E4%B9%88_key_%E6%98%AF%E5%BF%85%E9%A1%BB%E7%9A%84/"},"publisher":{"@type":"Organization","name":"不如吃茶去","logo":{"@type":"ImageObject","url":"https://img.zburu.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zburu-hugo.vercel.app accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zburu-hugo.vercel.app/posts title=posts><span>posts</span></a></li><li><a href=https://zburu-hugo.vercel.app/categories title=categories><span>categories</span></a></li><li><a href=https://zburu-hugo.vercel.app/tags title=tags><span>tags</span></a></li><li><a href=https://zburu-hugo.vercel.app/search title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://zburu-hugo.vercel.app/about title=about><span>about</span></a></li><li><a href=https://github.com/zburu title=github><span>github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zburu-hugo.vercel.app>Home</a>&nbsp;»&nbsp;<a href=https://zburu-hugo.vercel.app/posts/>Posts</a></div><h1 class=post-title>为什么 key 是必须的？</h1><div class=post-meta><span title='2021-01-01 20:48:00 +0000 UTC'>January 1, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;111 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/zburu/hugo-blog/blob/main/content/posts/2021-01-01-%e4%b8%ba%e4%bb%80%e4%b9%88_key_%e6%98%af%e5%bf%85%e9%a1%bb%e7%9a%84%ef%bc%9f.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=post-content><p>之前有说到，在 React 中渲染列表的时候，要给每一个数据加一个 key 值，赋予一个确定的标示，而且也详细描述了如何给一个标示，方法知道了，那么为什么要这么做呢？</p><p><a href=../20201216-react-note-2/#%E4%B8%89%E3%80%81%E8%BD%AC%E6%8D%A2%E5%88%97%E8%A1%A8>在 React 中如何渲染列表？</a></p><p>在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。</p><p>在子元素列表末尾新增元素时，更新开销比较小。比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span><span class=p>&gt;</span>first<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span><span class=p>&gt;</span>second<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span><span class=p>&gt;</span>first<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span><span class=p>&gt;</span>second<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span><span class=p>&gt;</span>third<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>React 会先匹配两个 <code>&lt;li>first&lt;/li></code> 对应的树，然后匹配第二个元素 <code>&lt;li>second&lt;/li></code> 对应的树，最后插入第三个元素的 <code>&lt;li>third&lt;/li></code> 树。</p><p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span><span class=p>&gt;</span>Duke<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span><span class=p>&gt;</span>Villanova<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span><span class=p>&gt;</span>Connecticut<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span><span class=p>&gt;</span>Duke<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span><span class=p>&gt;</span>Villanova<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>React 不会意识到应该保留 <code>&lt;li>Duke&lt;/li></code> 和 <code>&lt;li>Villanova&lt;/li></code>，而是会重建每一个子元素 。这种情况会带来性能问题。</p><p><strong>key</strong></p><p>为了解决上述问题， React 支持 <code>key</code> 属性，当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下例子在新增 <code>key</code> 之后使得之前的低效转换变得高效：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span> <span class=na>key</span><span class=o>=</span><span class=s>&#34;1&#34;</span><span class=p>&gt;</span>Duke<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span> <span class=na>key</span><span class=o>=</span><span class=s>&#34;2&#34;</span><span class=p>&gt;</span>Villanova<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span> <span class=na>key</span><span class=o>=</span><span class=s>&#34;0&#34;</span><span class=p>&gt;</span>Connecticut<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span> <span class=na>key</span><span class=o>=</span><span class=s>&#34;1&#34;</span><span class=p>&gt;</span>Duke<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>li</span> <span class=na>key</span><span class=o>=</span><span class=s>&#34;2&#34;</span><span class=p>&gt;</span>Villanova<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>现在 React 知道只有带着 <code>'0'</code> key 的元素是新元素，带着 <code>'1'</code> 以及 <code>'2'</code> key 的元素仅仅移动了。</p><p>现实场景中，产生一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>li</span> <span class=na>key</span><span class=o>=</span><span class=s>{item.id}</span><span class=p>&gt;</span>{item.name}<span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。</p><p>最后，你也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变得慢。</p><p>当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改导致无法预期的变动。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zburu-hugo.vercel.app/tags/react/>react</a></li></ul><nav class=paginav><a class=prev href=https://zburu-hugo.vercel.app/posts/2021-01-04-%E5%A6%82%E4%BD%95%E5%9C%A8_react_%E4%B8%AD%E5%BC%95%E5%85%A5_less_/><span class=title>« Prev</span><br><span>如何在 React 中引入 less？</span></a>
<a class=next href=https://zburu-hugo.vercel.app/posts/2020-12-29-react_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/><span class=title>Next »</span><br><span>React 学习笔记（三）</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://zburu-hugo.vercel.app>不如吃茶去</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>