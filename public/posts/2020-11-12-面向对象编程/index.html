<!DOCTYPE html>
<html><head>
<title>面向对象编程</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">



<meta property="og:title" content="面向对象编程" />
<meta property="og:description" content="面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
一、什么是面向对象编程 js是基于原型的，基于面向对象编程
面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类
1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。
自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用
面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。
2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统
面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
想要弄明白面向对象，需要先理解类和对象的概念
《什么是类和对象？》
二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = &#39;小明&#39;; person.age = 22; person.year = function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) }; person.year(); // 字面量 var student = { name: &#39;小明&#39;, age: 22, year: function () { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出： 缺点：重复实例化对象，代码冗余高" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/2020-11-12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-12T12:58:00+00:00" />
<meta property="article:modified_time" content="2020-11-12T12:58:00+00:00" /><meta property="og:site_name" content="My Blog" />






<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="面向对象编程"/>
<meta name="twitter:description" content="面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
一、什么是面向对象编程 js是基于原型的，基于面向对象编程
面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类
1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。
自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用
面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。
2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统
面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
想要弄明白面向对象，需要先理解类和对象的概念
《什么是类和对象？》
二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = &#39;小明&#39;; person.age = 22; person.year = function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) }; person.year(); // 字面量 var student = { name: &#39;小明&#39;, age: 22, year: function () { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出： 缺点：重复实例化对象，代码冗余高"/>







<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">


  






<link rel="stylesheet" href="/scss/journal.min.0f46f98b723f2aad4b02d9370bb6aa7848b5c2b2a5579642014082283683d2d8.css" integrity="sha256-D0b5i3I/Kq1LAtk3C7aqeEi1wrKlV5ZCAUCCKDaD0tg=" media="screen">



<link rel="stylesheet" href="/scss/dark-mode.min.79c34391dbcff20df8b4dac718e2606701efcbfdb9f3b08447ac39ac9dc7b463.css" integrity="sha256-ecNDkdvP8g34tNrHGOJgZwHvy/2587CER6w5rJ3HtGM=" media="screen">


<script src="/vendor/js/loadCSS.js"></script>
<script>
  loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons");
</script>






  <script src="/js/toc.js"></script>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/vendor/js/md5.min.js"></script>
<script>
  var gitalk = new Gitalk({
  clientID: 'your client id',
  clientSecret: 'your client secret',
  repo: 'repo name',
  owner: 'user',
  admin: ['user'],
  id: md5(location.pathname),
  distractionFreeMode: 'false'
  });
  window.onload = function () {
        gitalk.render('gitalk-container')
  }
</script>












</head>
<body>
    	<div id="app"><div id="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="http://example.org/">
    
        <div class="nav-title">
            A Hugo Site
        </div>
        
        <div class="nav-subtitle">
            Themed by Diary.
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/posts">
                Archive
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                Categories
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                Tags
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/index.xml">
                RSS Feed
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
Ported from <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	This is a customized copyright.
	

    </div>
    
</div><div id="extraContainer" class="extra-container">
    
    
    <div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e4%b8%80%e4%bb%80%e4%b9%88%e6%98%af%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b" onclick="onNavClick(`#一什么是面向对象编程-nav`)" id="一什么是面向对象编程-nav">
									一、什么是面向对象编程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#1%e9%9d%a2%e5%90%91%e8%bf%87%e7%a8%8b%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1" onclick="onNavClick(`#1面向过程程序设计-nav`)" id="1面向过程程序设计-nav">
									1.面向过程程序设计
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#2%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1" onclick="onNavClick(`#2面向对象程序设计-nav`)" id="2面向对象程序设计-nav">
									2.面向对象程序设计
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e4%ba%8c%e5%88%9b%e5%bb%ba%e5%af%b9%e8%b1%a1%e7%9a%84%e6%96%b9%e6%b3%95" onclick="onNavClick(`#二创建对象的方法-nav`)" id="二创建对象的方法-nav">
									二、创建对象的方法
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#1%e5%88%9b%e5%bb%ba%e5%ad%97%e9%9d%a2%e9%87%8f%e5%92%8c%e5%ae%9e%e4%be%8b" onclick="onNavClick(`#1创建字面量和实例-nav`)" id="1创建字面量和实例-nav">
									1.创建字面量和实例
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#2%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#2工厂模式-nav`)" id="2工厂模式-nav">
									2.工厂模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#3%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" onclick="onNavClick(`#3构造函数-nav`)" id="3构造函数-nav">
									3.构造函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#4-%e5%8e%9f%e5%9e%8b%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#4-原型模式-nav`)" id="4-原型模式-nav">
									4. 原型模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#5%e6%b7%b7%e5%90%88%e6%a8%a1%e5%bc%8f%e6%8e%a8%e8%8d%90%e4%bd%bf%e7%94%a8" onclick="onNavClick(`#5混合模式推荐使用-nav`)" id="5混合模式推荐使用-nav">
									5.混合模式(推荐使用)
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e4%b8%89%e5%8e%9f%e5%9e%8b%e5%8e%9f%e5%9e%8b%e9%93%be" onclick="onNavClick(`#三原型原型链-nav`)" id="三原型原型链-nav">
									三、原型，原型链
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#1%e5%8e%9f%e5%9e%8b%e5%af%b9%e8%b1%a1" onclick="onNavClick(`#1原型对象-nav`)" id="1原型对象-nav">
									1.原型对象
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#2__proto__%e5%92%8cprototype%e7%9a%84%e5%8c%ba%e5%88%ab" onclick="onNavClick(`#2__proto__和prototype的区别-nav`)" id="2__proto__和prototype的区别-nav">
									2.__proto__和prototype的区别
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#3%e7%bb%a7%e6%89%bf" onclick="onNavClick(`#3继承-nav`)" id="3继承-nav">
									3.继承
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#4es6%e6%96%b0%e6%96%b9%e6%b3%95class" onclick="onNavClick(`#4es6新方法class-nav`)" id="4es6新方法class-nav">
									4.ES6新方法－－class
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        <a type="button" class="pagination-action" id="darkModeToggleButton">
            <span class="material-icons pagination-action-icon" id="darkModeToggleIcon">
                dark_mode
            </span>
        </a>
        
        
    </div>
</div>
<div class="single-column-drawer-container" id="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/posts">
                    Archive
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    Categories
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    Tags
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/index.xml">
                    RSS Feed
                </a>
                
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e4%b8%80%e4%bb%80%e4%b9%88%e6%98%af%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b" onclick="onNavClick(`#一什么是面向对象编程-nav`)" id="一什么是面向对象编程-nav">
									一、什么是面向对象编程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#1%e9%9d%a2%e5%90%91%e8%bf%87%e7%a8%8b%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1" onclick="onNavClick(`#1面向过程程序设计-nav`)" id="1面向过程程序设计-nav">
									1.面向过程程序设计
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#2%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1" onclick="onNavClick(`#2面向对象程序设计-nav`)" id="2面向对象程序设计-nav">
									2.面向对象程序设计
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e4%ba%8c%e5%88%9b%e5%bb%ba%e5%af%b9%e8%b1%a1%e7%9a%84%e6%96%b9%e6%b3%95" onclick="onNavClick(`#二创建对象的方法-nav`)" id="二创建对象的方法-nav">
									二、创建对象的方法
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#1%e5%88%9b%e5%bb%ba%e5%ad%97%e9%9d%a2%e9%87%8f%e5%92%8c%e5%ae%9e%e4%be%8b" onclick="onNavClick(`#1创建字面量和实例-nav`)" id="1创建字面量和实例-nav">
									1.创建字面量和实例
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#2%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#2工厂模式-nav`)" id="2工厂模式-nav">
									2.工厂模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#3%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" onclick="onNavClick(`#3构造函数-nav`)" id="3构造函数-nav">
									3.构造函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#4-%e5%8e%9f%e5%9e%8b%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#4-原型模式-nav`)" id="4-原型模式-nav">
									4. 原型模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#5%e6%b7%b7%e5%90%88%e6%a8%a1%e5%bc%8f%e6%8e%a8%e8%8d%90%e4%bd%bf%e7%94%a8" onclick="onNavClick(`#5混合模式推荐使用-nav`)" id="5混合模式推荐使用-nav">
									5.混合模式(推荐使用)
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e4%b8%89%e5%8e%9f%e5%9e%8b%e5%8e%9f%e5%9e%8b%e9%93%be" onclick="onNavClick(`#三原型原型链-nav`)" id="三原型原型链-nav">
									三、原型，原型链
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#1%e5%8e%9f%e5%9e%8b%e5%af%b9%e8%b1%a1" onclick="onNavClick(`#1原型对象-nav`)" id="1原型对象-nav">
									1.原型对象
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#2__proto__%e5%92%8cprototype%e7%9a%84%e5%8c%ba%e5%88%ab" onclick="onNavClick(`#2__proto__和prototype的区别-nav`)" id="2__proto__和prototype的区别-nav">
									2.__proto__和prototype的区别
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#3%e7%bb%a7%e6%89%bf" onclick="onNavClick(`#3继承-nav`)" id="3继承-nav">
									3.继承
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#4es6%e6%96%b0%e6%96%b9%e6%b3%95class" onclick="onNavClick(`#4es6新方法class-nav`)" id="4es6新方法class-nav">
									4.ES6新方法－－class
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div id="drawer-mask" v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav id="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div id="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a id="navTitle" class="navbar-brand" href="http://example.org/">
            A Hugo Site
        </a>
        
        <button type="button" class="nav-darkmode-toggle" id="darkModeToggleButton2">
            <i class="material-icons" id="darkModeToggleIcon2">
                dark_mode
            </i>
        </button>
        
    </div>
</nav>
<div class="single-column-header-container" id="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="http://example.org/">
        <div class="single-column-header-title">A Hugo Site</div>
        
        <div class="single-column-header-subtitle">Themed by Diary.</div>
        

    </a>
</div>

            <div id="content">
                <div id="streamContainer" class="stream-container">

    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper-text-only"
                
            >
                <div class="post-title">
                    面向对象编程
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2020-11-12 12:58
                        </time>
                        

                        
                            <i class="material-icons" style="">folder</i>
                                <a href="/categories/">[技术]</a>
                                &nbsp;
                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/%E7%BC%96%E7%A8%8B">编程</a>
                                &nbsp;
                            
                                <a href="/tags/js">js</a>
                                &nbsp;
                            
                        
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    <p>面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。</p>
<!-- raw HTML omitted -->
<h2 id="一什么是面向对象编程">一、什么是面向对象编程</h2>
<p>js是<code>基于原型</code>的，基于<code>面向对象编程</code></p>
<p>面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类</p>
<p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/99809398-db39-4c68-97b2-83ff9971f2c6.png" alt=""></p>
<!-- raw HTML omitted -->
<h3 id="1面向过程程序设计">1.面向过程程序设计</h3>
<p>将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。</p>
<p>自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用</p>
<p>面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。</p>
<h3 id="2面向对象程序设计">2.面向对象程序设计</h3>
<p>将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统</p>
<p>面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。</p>
<p>想要弄明白面向对象，需要先理解类和对象的概念</p>
<p><a href="../20201118-objects-interfaces-classes">《什么是类和对象？》</a></p>
<h2 id="二创建对象的方法">二、创建对象的方法</h2>
<h3 id="1创建字面量和实例">1.创建字面量和实例</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#658b00">window</span>.onload = <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 实例
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">var</span> person = <span style="color:#8b008b;font-weight:bold">new</span> <span style="color:#658b00">Object</span>();
</span></span><span style="display:flex;"><span>    person.name = <span style="color:#cd5555">&#39;小明&#39;</span>;
</span></span><span style="display:flex;"><span>    person.age = <span style="color:#b452cd">22</span>;
</span></span><span style="display:flex;"><span>    person.year = <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>        console.log(<span style="color:#8b008b;font-weight:bold">this</span>.name + <span style="color:#cd5555">&#39;今年&#39;</span> + <span style="color:#8b008b;font-weight:bold">this</span>.age + <span style="color:#cd5555">&#39;岁了！&#39;</span>)
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    person.year();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 字面量
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">var</span> student = {
</span></span><span style="display:flex;"><span>        name: <span style="color:#cd5555">&#39;小明&#39;</span>,
</span></span><span style="display:flex;"><span>        age: <span style="color:#b452cd">22</span>,
</span></span><span style="display:flex;"><span>        year: <span style="color:#8b008b;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#8b008b;font-weight:bold">this</span>.name + <span style="color:#cd5555">&#39;今年&#39;</span> + <span style="color:#8b008b;font-weight:bold">this</span>.age + <span style="color:#cd5555">&#39;岁了！&#39;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    student.year();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">// 小明今年22岁了！
</span></span></span></code></pre></div><p>两者输出的结果是一样的，控制台输出：
<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/c8eb2a0d-5c3a-461e-b699-79653edcd986.jpg" alt=""></p>
<blockquote>
<p>缺点：重复实例化对象，代码冗余高</p>
</blockquote>
<h3 id="2工厂模式">2.工厂模式</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#658b00">window</span>.onload = <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> createObj(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">var</span> obj = <span style="color:#8b008b;font-weight:bold">new</span> <span style="color:#658b00">Object</span>();
</span></span><span style="display:flex;"><span>        obj.name = name,
</span></span><span style="display:flex;"><span>        obj.age = age,
</span></span><span style="display:flex;"><span>        obj.year = <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#8b008b;font-weight:bold">this</span>.name + <span style="color:#cd5555">&#39;今年&#39;</span> + <span style="color:#8b008b;font-weight:bold">this</span>.age + <span style="color:#cd5555">&#39;岁了！&#39;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">return</span> obj;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">var</span> obj = createObj(<span style="color:#cd5555">&#39;小明&#39;</span>, <span style="color:#b452cd">22</span>);
</span></span><span style="display:flex;"><span>    obj.year();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote>
<p>优点：解决重复实例化对象的问题
缺点：无法识别对象的类型，因为所有的实例都指向一个原型</p>
</blockquote>
<h3 id="3构造函数">3.构造函数</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#658b00">window</span>.onload = <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> Person(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.year = <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#8b008b;font-weight:bold">this</span>.name + <span style="color:#cd5555">&#39;今年&#39;</span> + <span style="color:#8b008b;font-weight:bold">this</span>.age + <span style="color:#cd5555">&#39;岁了！&#39;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">var</span> student = <span style="color:#8b008b;font-weight:bold">new</span> Person(<span style="color:#cd5555">&#39;小明&#39;</span>, <span style="color:#b452cd">22</span>);
</span></span><span style="display:flex;"><span>    student.year();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote>
<p>优点：可以识别对象的类型
缺点：多个实例重复创建方法，无法共享</p>
</blockquote>
<h3 id="4-原型模式">4. 原型模式</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#658b00">window</span>.onload = <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> Par() {}
</span></span><span style="display:flex;"><span>    Par.prototype = {
</span></span><span style="display:flex;"><span>        constructor: <span style="color:#cd5555">&#39;Par&#39;</span>,
</span></span><span style="display:flex;"><span>        name: <span style="color:#cd5555">&#39;小明&#39;</span>,
</span></span><span style="display:flex;"><span>        age: <span style="color:#b452cd">22</span>,
</span></span><span style="display:flex;"><span>        year: <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#8b008b;font-weight:bold">this</span>.name + <span style="color:#cd5555">&#39;今年&#39;</span> + <span style="color:#8b008b;font-weight:bold">this</span>.age + <span style="color:#cd5555">&#39;岁了！&#39;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">var</span> son = <span style="color:#8b008b;font-weight:bold">new</span> Par();
</span></span><span style="display:flex;"><span>    son.year();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote>
<p>缺点：所有实例共享他的属性和方法，不能传参和初始化属性值</p>
</blockquote>
<h3 id="5混合模式推荐使用">5.混合模式(推荐使用)</h3>
<p>是构造函数和原型模式混合的写法，拥有各自的优点，构造函数共享实例属性，原型模式共享方法和想要共享的属性，可以传参和初始化属性值</p>
<p>先用构造函数定义对象的属性方法，然后用原型模式创建方法，使用的属性通过prototype获取，有一个constructor属性，可以指向要操作的函数对象（构造函数）</p>
<p>比如<code>constructor: Par</code>，就代表下面这个原型方法指向<code>Par()</code>对象（构造函数）</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#658b00">window</span>.onload = <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> Par(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Par.prototype = {
</span></span><span style="display:flex;"><span>        constructor: Par,
</span></span><span style="display:flex;"><span>        year: <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#8b008b;font-weight:bold">this</span>.name + <span style="color:#cd5555">&#39;今年&#39;</span> + <span style="color:#8b008b;font-weight:bold">this</span>.age + <span style="color:#cd5555">&#39;岁了！&#39;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">var</span> son = <span style="color:#8b008b;font-weight:bold">new</span> Par(<span style="color:#cd5555">&#39;小明&#39;</span>, <span style="color:#b452cd">22</span>)
</span></span><span style="display:flex;"><span>    son.year();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">// 小明今年22岁了！
</span></span></span></code></pre></div><h2 id="三原型原型链">三、原型，原型链</h2>
<h3 id="1原型对象">1.原型对象</h3>
<ol>
<li>函数对象都具有<code>prototype</code>属性，它指向函数的原型对象(浏览器内存创建的对象)，原型对象都具有<code>constructor</code>属性，它指向<code>prototype</code>属性所在的函数对象(构造函数)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#658b00">window</span>.onload = <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> Par(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Par.prototype = {
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// constructor指向对象
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>        constructor: Par,
</span></span><span style="display:flex;"><span>        year: <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#8b008b;font-weight:bold">this</span>.name + <span style="color:#cd5555">&#39;今年&#39;</span> + <span style="color:#8b008b;font-weight:bold">this</span>.age + <span style="color:#cd5555">&#39;岁了！&#39;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">var</span> son = <span style="color:#8b008b;font-weight:bold">new</span> Par(<span style="color:#cd5555">&#39;小明&#39;</span>, <span style="color:#b452cd">22</span>)
</span></span><span style="display:flex;"><span>    son.year();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">/*********************************************/</span>
</span></span><span style="display:flex;"><span>    console.log(Par.prototype)
</span></span><span style="display:flex;"><span>    console.log(Par.prototype.constructor)
</span></span><span style="display:flex;"><span><span style="color:#228b22">/*********************************************/</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通过控制台可以看到</p>
<p>构造函数的<code>prototypr</code>属性指向原型对象</p>
<p>原型对象的<code>construcyor</code>属性指向构造函数</p>
<p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/769d7f85-0893-4896-84ac-8cb03b8e55d6.jpg" alt=""></p>
<ol start="2">
<li>当调用构造函数创建一个实例后，该实例会有一个隐藏属性<code>__proto__ </code>，它指向构造函数的原型对象</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>console.log(son.__proto__ === Par.prototype)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">// true
</span></span></span></code></pre></div><ol start="3">
<li>所有的构造函数的prototype都是object类型</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>console.log(<span style="color:#8b008b;font-weight:bold">typeof</span> Par.prototype)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">// object
</span></span></span></code></pre></div><ol start="4">
<li>Function的prototype是一个空函数，所有内置函数的__proto__属性都指向这个空函数</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>console.log(<span style="color:#658b00">Math</span>.__proto__)
</span></span></code></pre></div><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/47a21be9-e931-48e5-8724-96e7af58ab85.jpg" alt=""></p>
<ol start="5">
<li>如果构造函数实例和原型对象中同时定义了一个属性，在调用时，会屏蔽原型对象中的属性，如果想要访问原型对象中的属性值，需要通过<code>delete</code>方法将同名属性在实例（构造函数）中彻底删除</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#658b00">window</span>.onload = <span style="color:#8b008b;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> Par(name) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Par.prototype.name = <span style="color:#cd5555">&#34;张三&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">var</span> son = <span style="color:#8b008b;font-weight:bold">new</span> Par(<span style="color:#cd5555">&#34;李四&#34;</span>);
</span></span><span style="display:flex;"><span>    console.log(son.name); <span style="color:#228b22">// 李四
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    console.log(son.__proto__.name); <span style="color:#228b22">// 张三
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 使用delete删除实例的同名属性值
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    console.log(<span style="color:#8b008b;font-weight:bold">delete</span> son.name);   <span style="color:#228b22">// true
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    console.log(son.name); <span style="color:#228b22">// 张三
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span></code></pre></div><ol start="6">
<li>通过<code>hasOwnProperty(属性名)</code>可以判断一个属性存在于构造函数中，还是原型对象中</li>
</ol>
<blockquote>
<p><code>true</code>表示存在构造函数中；<code>false</code>表示存在原型对象中</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>console.log(Par.hasOwnProperty(name));  <span style="color:#228b22">// false
</span></span></span></code></pre></div><ol start="7">
<li>操作符<code>in</code>，可以判断一个属性是否存在（存在于构造函数和原型对象中皆可）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#658b00">window</span>.onload = <span style="color:#8b008b;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> Par(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Par.prototype = {
</span></span><span style="display:flex;"><span>        constructor: Par,
</span></span><span style="display:flex;"><span>        year: <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#8b008b;font-weight:bold">this</span>.name + <span style="color:#8b008b;font-weight:bold">this</span>.age)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">var</span> son = <span style="color:#8b008b;font-weight:bold">new</span> Par(<span style="color:#cd5555">&#39;xm&#39;</span>, <span style="color:#cd5555">&#39;22&#39;</span>)
</span></span><span style="display:flex;"><span>    son.year();
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#cd5555">&#39;name&#39;</span> <span style="color:#8b008b;font-weight:bold">in</span> Par); <span style="color:#228b22">// true
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    console.log(<span style="color:#cd5555">&#39;age&#39;</span> <span style="color:#8b008b;font-weight:bold">in</span> Par);  <span style="color:#228b22">// false
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span></code></pre></div><p>同样的两个属性，判断其是否存在于实例或者原型对象中，输出的结果不一样</p>
<blockquote>
<p>参考:《对象中是否有某一个属性 in》<a href="https://www.cnblogs.com/IwishIcould/p/12333739.html">https://www.cnblogs.com/IwishIcould/p/12333739.html</a></p>
</blockquote>
<h3 id="2__proto__和prototype的区别">2.__proto__和prototype的区别</h3>
<ol>
<li>
<p><code>prototype</code>属性只有函数对象上才有，而<code>__proto__</code>属性所有对象都有</p>
</li>
<li>
<p><code>prototype</code>是由函数对象指向原型对象，而<code>__proto__</code>是由实例指向函数对象的原型对象</p>
</li>
<li>
<p>原型链，将父类型的实例作为子类型的原型对象，这种链式关系叫做<code>原型链</code></p>
</li>
</ol>
<p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/ed2c179f-0e9d-4da0-bae3-00d2273b10c6.png" alt=""></p>
<h3 id="3继承">3.继承</h3>
<ol>
<li>原型链继承</li>
</ol>
<blockquote>
<p>优点：父类原型定义的属性和方法可以复用
缺点：子类实例没有自己的属性，不能向父类传递参数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">function</span> test1() {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> SuperType() {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.city = [ <span style="color:#cd5555">&#34;北京&#34;</span>, <span style="color:#cd5555">&#34;上海&#34;</span>, <span style="color:#cd5555">&#34;天津&#34;</span> ];
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.property = <span style="color:#8b008b;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    SuperType.prototype = {
</span></span><span style="display:flex;"><span>        constructor : SuperType,     <span style="color:#228b22">// 保持构造函数和原型对象的完整性
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>        age : <span style="color:#b452cd">15</span>,
</span></span><span style="display:flex;"><span>        getSuperValue : <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#8b008b;font-weight:bold">return</span> <span style="color:#8b008b;font-weight:bold">this</span>.property;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> SonType() {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.property = <span style="color:#8b008b;font-weight:bold">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 重写子类的原型指向父类的实例：继承父类的原型
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    SubType.prototype = <span style="color:#8b008b;font-weight:bold">new</span> SuperType();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    SubType.prototype = {
</span></span><span style="display:flex;"><span>        constructor : SubType,
</span></span><span style="display:flex;"><span>        getSonType : <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#8b008b;font-weight:bold">return</span> <span style="color:#8b008b;font-weight:bold">this</span>.property;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 优点验证
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">let</span> son = <span style="color:#8b008b;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    console.log(son.age); <span style="color:#228b22">// 15
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    console.log(son.getSuperValue()); <span style="color:#228b22">// false
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 缺点验证
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">let</span> instance1 = <span style="color:#8b008b;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    instance1.city.push(<span style="color:#cd5555">&#34;重庆&#34;</span>);
</span></span><span style="display:flex;"><span>    console.log(instance1.city); <span style="color:#228b22">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">let</span> instance2 = <span style="color:#8b008b;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    console.log(instance2.city); <span style="color:#228b22">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">// test1();
</span></span></span></code></pre></div><ol start="2">
<li>构造函数继承</li>
</ol>
<blockquote>
<p>优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点
缺点：父类原型的属性和方法不可复用</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">function</span> test2() {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> SuperType(name) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.city = [ <span style="color:#cd5555">&#34;北京&#34;</span>, <span style="color:#cd5555">&#34;上海&#34;</span>, <span style="color:#cd5555">&#34;天津&#34;</span> ]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    SuperType.prototype = {
</span></span><span style="display:flex;"><span>        constructor : SuperType,
</span></span><span style="display:flex;"><span>        age : <span style="color:#b452cd">18</span>,
</span></span><span style="display:flex;"><span>        showInfo : <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#8b008b;font-weight:bold">return</span> <span style="color:#8b008b;font-weight:bold">this</span>.name;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> SubType() {
</span></span><span style="display:flex;"><span>        <span style="color:#228b22">// 父类调用call()或者apply()方法和子类共用同一个this，实现子类实例属性的继承
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>        SuperType.call(<span style="color:#8b008b;font-weight:bold">this</span>, <span style="color:#cd5555">&#34;张三&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 优点验证
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">let</span> instance = <span style="color:#8b008b;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    instance.city.push(<span style="color:#cd5555">&#34;重庆&#34;</span>);
</span></span><span style="display:flex;"><span>    console.log(instance.city); <span style="color:#228b22">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">let</span> instance1 = <span style="color:#8b008b;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    console.log(instance1.city); <span style="color:#228b22">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 缺点验证
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    console.log(instance.age); <span style="color:#228b22">// undefined
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    instance.showInfo(); <span style="color:#228b22">// son.showInfo is not a function
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">// test2();
</span></span></span></code></pre></div><ol start="3">
<li>组合继承（推荐）</li>
</ol>
<blockquote>
<p>优点：原型的属性和方法可以复用，每个子类实例都有自己的属性
缺点：父类构造函数调用了两次，子类原型中的父类实例属性被子类实例覆盖</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">function</span> test3() {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> SuperType(name) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.city = [ <span style="color:#cd5555">&#34;北京&#34;</span>, <span style="color:#cd5555">&#34;上海&#34;</span>, <span style="color:#cd5555">&#34;天津&#34;</span> ]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    SuperType.prototype = {
</span></span><span style="display:flex;"><span>        constructor : SuperType,
</span></span><span style="display:flex;"><span>        showInfo : <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#8b008b;font-weight:bold">this</span>.name + <span style="color:#cd5555">&#34;今年&#34;</span> + <span style="color:#8b008b;font-weight:bold">this</span>.age + <span style="color:#cd5555">&#34;岁了&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> SubType(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#228b22">// 1. 通过构造方法继承实现实例属性的继承
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>        SuperType.call(<span style="color:#8b008b;font-weight:bold">this</span>, name);
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 2. 通过原型链继承实现原型方法的继承
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    SubType.prototype = <span style="color:#8b008b;font-weight:bold">new</span> SuperType();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 优点验证
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">let</span> instance = <span style="color:#8b008b;font-weight:bold">new</span> SubType(<span style="color:#cd5555">&#34;张三&#34;</span>, <span style="color:#b452cd">15</span>);
</span></span><span style="display:flex;"><span>    instance.showInfo(); <span style="color:#228b22">// 张三今年15岁了
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">let</span> instance1 = <span style="color:#8b008b;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    instance1.city.push(<span style="color:#cd5555">&#34;重庆&#34;</span>);
</span></span><span style="display:flex;"><span>    console.log(instance1.city); <span style="color:#228b22">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">let</span> instance2 = <span style="color:#8b008b;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    console.log(instance2.city); <span style="color:#228b22">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">// test3();
</span></span></span></code></pre></div><ol start="4">
<li>寄生组合继承（推荐）</li>
</ol>
<blockquote>
<p>优点：解决了组合继承的缺点，效率高
缺点：基本没有</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">function</span> test4() {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> inheritPrototype(subType, superType) {
</span></span><span style="display:flex;"><span>        <span style="color:#228b22">// 1. 继承父类的原型
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">var</span> prototype = <span style="color:#658b00">Object</span>.create(superType.prototype);
</span></span><span style="display:flex;"><span>        <span style="color:#228b22">// 2. 重写被污染的construct
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>        prototype.constructor = subType;
</span></span><span style="display:flex;"><span>        <span style="color:#228b22">// 3. 重写子类的原型
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>        subType.prototype = prototype;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> SuperType(name) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.city = [ <span style="color:#cd5555">&#34;北京&#34;</span>, <span style="color:#cd5555">&#34;上海&#34;</span>, <span style="color:#cd5555">&#34;天津&#34;</span> ];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    SuperType.prototype.sayName = <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>        console.log(<span style="color:#8b008b;font-weight:bold">this</span>.name);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">function</span> SubType(name, age) {
</span></span><span style="display:flex;"><span>        SuperType.call(<span style="color:#8b008b;font-weight:bold">this</span>, name);
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 将父类原型指向子类
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    inheritPrototype(SubType, SuperType);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    SubType.prototype.sayAge = <span style="color:#8b008b;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>        console.log(<span style="color:#8b008b;font-weight:bold">this</span>.age);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// 优点验证
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">let</span> instance = <span style="color:#8b008b;font-weight:bold">new</span> SubType(<span style="color:#cd5555">&#34;张三&#34;</span>, <span style="color:#b452cd">15</span>);
</span></span><span style="display:flex;"><span>    instance.sayName(); <span style="color:#228b22">// 张三
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">let</span> instance1 = <span style="color:#8b008b;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    instance1.city.push(<span style="color:#cd5555">&#34;重庆&#34;</span>);
</span></span><span style="display:flex;"><span>    console.log(instance1.city); <span style="color:#228b22">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">let</span> instance2 = <span style="color:#8b008b;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    console.log(instance2.city); <span style="color:#228b22">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#228b22">// test4();
</span></span></span></code></pre></div><h3 id="4es6新方法class">4.ES6新方法－－class</h3>
<p>新的关键字<code>class</code>在es6开始被引入到javascript中来，<code>class</code>的目的就是让定义类更简单</p>
<p>用函数方法实现：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">function</span> Person(name) {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Person.prototype.hello = <span style="color:#8b008b;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#cd5555">&#39;Hello, &#39;</span> + <span style="color:#8b008b;font-weight:bold">this</span>.name + <span style="color:#cd5555">&#39;!&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">var</span> son = <span style="color:#8b008b;font-weight:bold">new</span> Person(<span style="color:#cd5555">&#39;xm&#39;</span>)
</span></span><span style="display:flex;"><span>son.hello();    <span style="color:#228b22">// Hello, xm!
</span></span></span></code></pre></div><p>用<code>class</code>来实现：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> Person {
</span></span><span style="display:flex;"><span>    constructor(name) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    hello() {
</span></span><span style="display:flex;"><span>        console.log(<span style="color:#cd5555">&#39;Hello, &#39;</span> + <span style="color:#8b008b;font-weight:bold">this</span>.name + <span style="color:#cd5555">&#39;!&#39;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">var</span> son = <span style="color:#8b008b;font-weight:bold">new</span> person(<span style="color:#cd5555">&#39;xm&#39;</span>)
</span></span><span style="display:flex;"><span>son.hello();    <span style="color:#228b22">// Hello, xm!
</span></span></span></code></pre></div><p>可以在看到，在定义<code>class</code>中，直接包含了构造函数<code>constructor</code>属性，和原型对象上的函数<code>hello()</code>方法，省略掉了<code>function</code>关键字</p>
<p>需要注意：原来的写法是，构造函数和原型对象分散开来写，现在用<code>class</code>可以直接把两者串在一个对象中，只有最后传参和调用方法时写法是一样的</p>
<p><strong>class继承</strong></p>
<p>用<code>class</code>定义对象的另一个巨大的好处是继承更方便了。想一想我们从<code>Person</code>派生一个<code>PrimaryPerson</code>需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过<code>extends</code>来实现：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> PrimaryPerson <span style="color:#8b008b;font-weight:bold">extends</span> Person {
</span></span><span style="display:flex;"><span>    constructor(name, grade) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b008b;font-weight:bold">super</span>(name); <span style="color:#228b22">// 记得用super调用父类的构造方法!
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>        <span style="color:#8b008b;font-weight:bold">this</span>.grade = grade;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    myGrade() {
</span></span><span style="display:flex;"><span>        alert(<span style="color:#cd5555">&#39;I am at grade &#39;</span> + <span style="color:#8b008b;font-weight:bold">this</span>.grade);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意<code>PrimaryPerson</code>的定义也是通过class关键字实现的，而<code>extends</code>则表示原型链对象来自<code>Person</code>，子类的构造函数可能会和父类的不太相同</p>
<p>例如，<code>PrimaryPerson</code>需要<code>name</code>和<code>grade</code>两个参数，并且需要通过<code>super(name)</code>来调用父类的构造函数，否则父类的<code>name</code>属性无法正常初始化。</p>
<p><code>PrimaryPerson</code>已经自动获得了父类<code>Person</code>的<code>hello方法</code>，我们又在子类中定义了新的<code>myGrade</code>方法。</p>
<p>ES6引入的<code>class</code>和原有的<code>JavaScript原型继承</code>有什么区别呢？</p>
<p>实际上它们没有任何区别，<code>class</code>的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用<code>class</code>的好处就是极大地简化了原型链代码。</p>
<p>但是！</p>
<p>目前并不是所有的浏览器都支持<code>class</code>，所以在选择的时候一定要慎重！</p>

                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">Last modified on 2020-11-12</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="/posts/2020-11-13-%E4%B8%BA%E4%BB%80%E4%B9%88gettime%E8%BF%94%E5%9B%9E1970%E5%B9%B4%E8%87%B3%E4%BB%8A%E7%9A%84%E6%AF%AB%E7%A7%92/">
			Next<br>为什么getTime()返回1970年至今的毫秒？
                </a>
                
                
                
                <a class="older-posts" href="/posts/2020-11-09-%E5%B0%8F%E5%BC%A0%E5%8E%A8%E6%88%BF%E6%97%A5%E8%AE%B0/">
			Previous<br>小张厨房日记
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                


<div id="gitalk-container"></div>









            </div>
        </div>
    </div>


                    </div>
            </div><div id="single-column-footer">
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
Ported from <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	This is a customized copyright.
	
</div>
            </div>
    
    <script src="/js/journal.js"></script>
    </body>
</html>
