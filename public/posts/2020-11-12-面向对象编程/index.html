<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>面向对象编程 | 子舒的博客</title><meta name=keywords content="编程,js"><meta name=description content="面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
一、什么是面向对象编程 js是基于原型的，基于面向对象编程
面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类
1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。
自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用
面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。
2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统
面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
想要弄明白面向对象，需要先理解类和对象的概念
《什么是类和对象？》
二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = '小明'; person.age = 22; person.year = function() { console.log(this.name + '今年' + this.age + '岁了！') }; person.year(); // 字面量 var student = { name: '小明', age: 22, year: function () { console.log(this.name + '今年' + this.age + '岁了！') } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出： 缺点：重复实例化对象，代码冗余高"><meta name=author content="Me"><link rel=canonical href=https://ioo.gay/posts/2020-11-12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ioo.gay/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ioo.gay/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ioo.gay/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ioo.gay/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ioo.gay/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="面向对象编程"><meta property="og:description" content="面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
一、什么是面向对象编程 js是基于原型的，基于面向对象编程
面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类
1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。
自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用
面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。
2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统
面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
想要弄明白面向对象，需要先理解类和对象的概念
《什么是类和对象？》
二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = '小明'; person.age = 22; person.year = function() { console.log(this.name + '今年' + this.age + '岁了！') }; person.year(); // 字面量 var student = { name: '小明', age: 22, year: function () { console.log(this.name + '今年' + this.age + '岁了！') } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出： 缺点：重复实例化对象，代码冗余高"><meta property="og:type" content="article"><meta property="og:url" content="https://ioo.gay/posts/2020-11-12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"><meta property="og:image" content="https://ioo.gay/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-12T12:58:00+00:00"><meta property="article:modified_time" content="2020-11-12T12:58:00+00:00"><meta property="og:site_name" content="不如吃茶去"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ioo.gay/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="面向对象编程"><meta name=twitter:description content="面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
一、什么是面向对象编程 js是基于原型的，基于面向对象编程
面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类
1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。
自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用
面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。
2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统
面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
想要弄明白面向对象，需要先理解类和对象的概念
《什么是类和对象？》
二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = '小明'; person.age = 22; person.year = function() { console.log(this.name + '今年' + this.age + '岁了！') }; person.year(); // 字面量 var student = { name: '小明', age: 22, year: function () { console.log(this.name + '今年' + this.age + '岁了！') } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出： 缺点：重复实例化对象，代码冗余高"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ioo.gay/posts/"},{"@type":"ListItem","position":2,"name":"面向对象编程","item":"https://ioo.gay/posts/2020-11-12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"面向对象编程","name":"面向对象编程","description":"面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。\n一、什么是面向对象编程 js是基于原型的，基于面向对象编程\n面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类\n1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。\n自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用\n面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。\n2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统\n面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。\n想要弄明白面向对象，需要先理解类和对象的概念\n《什么是类和对象？》\n二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = \u0026#39;小明\u0026#39;; person.age = 22; person.year = function() { console.log(this.name + \u0026#39;今年\u0026#39; + this.age + \u0026#39;岁了！\u0026#39;) }; person.year(); // 字面量 var student = { name: \u0026#39;小明\u0026#39;, age: 22, year: function () { console.log(this.name + \u0026#39;今年\u0026#39; + this.age + \u0026#39;岁了！\u0026#39;) } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出： 缺点：重复实例化对象，代码冗余高","keywords":["编程","js"],"articleBody":"面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。\n一、什么是面向对象编程 js是基于原型的，基于面向对象编程\n面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类\n1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。\n自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用\n面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。\n2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统\n面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。\n想要弄明白面向对象，需要先理解类和对象的概念\n《什么是类和对象？》\n二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = '小明'; person.age = 22; person.year = function() { console.log(this.name + '今年' + this.age + '岁了！') }; person.year(); // 字面量 var student = { name: '小明', age: 22, year: function () { console.log(this.name + '今年' + this.age + '岁了！') } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出： 缺点：重复实例化对象，代码冗余高\n2.工厂模式 window.onload = function() { function createObj(name, age) { var obj = new Object(); obj.name = name, obj.age = age, obj.year = function() { console.log(this.name + '今年' + this.age + '岁了！') } return obj; } var obj = createObj('小明', 22); obj.year(); } // 小明今年22岁了！ 优点：解决重复实例化对象的问题 缺点：无法识别对象的类型，因为所有的实例都指向一个原型\n3.构造函数 window.onload = function() { function Person(name, age) { this.name = name; this.age = age; this.year = function() { console.log(this.name + '今年' + this.age + '岁了！') } } var student = new Person('小明', 22); student.year(); } // 小明今年22岁了！ 优点：可以识别对象的类型 缺点：多个实例重复创建方法，无法共享\n4. 原型模式 window.onload = function() { function Par() {} Par.prototype = { constructor: 'Par', name: '小明', age: 22, year: function() { console.log(this.name + '今年' + this.age + '岁了！') } }; var son = new Par(); son.year(); } // 小明今年22岁了！ 缺点：所有实例共享他的属性和方法，不能传参和初始化属性值\n5.混合模式(推荐使用) 是构造函数和原型模式混合的写法，拥有各自的优点，构造函数共享实例属性，原型模式共享方法和想要共享的属性，可以传参和初始化属性值\n先用构造函数定义对象的属性方法，然后用原型模式创建方法，使用的属性通过prototype获取，有一个constructor属性，可以指向要操作的函数对象（构造函数）\n比如constructor: Par，就代表下面这个原型方法指向Par()对象（构造函数）\nwindow.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name + '今年' + this.age + '岁了！'); } }; var son = new Par('小明', 22) son.year(); } // 小明今年22岁了！ 三、原型，原型链 1.原型对象 函数对象都具有prototype属性，它指向函数的原型对象(浏览器内存创建的对象)，原型对象都具有constructor属性，它指向prototype属性所在的函数对象(构造函数) window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { // constructor指向对象 constructor: Par, year: function() { console.log(this.name + '今年' + this.age + '岁了！'); } }; var son = new Par('小明', 22) son.year(); /*********************************************/ console.log(Par.prototype) console.log(Par.prototype.constructor) /*********************************************/ } 通过控制台可以看到\n构造函数的prototypr属性指向原型对象\n原型对象的construcyor属性指向构造函数\n当调用构造函数创建一个实例后，该实例会有一个隐藏属性__proto__ ，它指向构造函数的原型对象 console.log(son.__proto__ === Par.prototype) // true 所有的构造函数的prototype都是object类型 console.log(typeof Par.prototype) // object Function的prototype是一个空函数，所有内置函数的__proto__属性都指向这个空函数 console.log(Math.__proto__) 如果构造函数实例和原型对象中同时定义了一个属性，在调用时，会屏蔽原型对象中的属性，如果想要访问原型对象中的属性值，需要通过delete方法将同名属性在实例（构造函数）中彻底删除 window.onload = function () { function Par(name) { this.name = name; } Par.prototype.name = \"张三\"; var son = new Par(\"李四\"); console.log(son.name); // 李四 console.log(son.__proto__.name); // 张三 // 使用delete删除实例的同名属性值 console.log(delete son.name); // true console.log(son.name); // 张三 } 通过hasOwnProperty(属性名)可以判断一个属性存在于构造函数中，还是原型对象中 true表示存在构造函数中；false表示存在原型对象中\nconsole.log(Par.hasOwnProperty(name)); // false 操作符in，可以判断一个属性是否存在（存在于构造函数和原型对象中皆可） window.onload = function () { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name + this.age) } }; var son = new Par('xm', '22') son.year(); console.log('name' in Par); // true console.log('age' in Par); // false } 同样的两个属性，判断其是否存在于实例或者原型对象中，输出的结果不一样\n参考:《对象中是否有某一个属性 in》https://www.cnblogs.com/IwishIcould/p/12333739.html\n2.__proto__和prototype的区别 prototype属性只有函数对象上才有，而__proto__属性所有对象都有\nprototype是由函数对象指向原型对象，而__proto__是由实例指向函数对象的原型对象\n原型链，将父类型的实例作为子类型的原型对象，这种链式关系叫做原型链\n3.继承 原型链继承 优点：父类原型定义的属性和方法可以复用 缺点：子类实例没有自己的属性，不能向父类传递参数\nfunction test1() { function SuperType() { this.city = [ \"北京\", \"上海\", \"天津\" ]; this.property = true; } SuperType.prototype = { constructor : SuperType, // 保持构造函数和原型对象的完整性 age : 15, getSuperValue : function() { return this.property; } }; function SonType() { this.property = false; } // 重写子类的原型指向父类的实例：继承父类的原型 SubType.prototype = new SuperType(); SubType.prototype = { constructor : SubType, getSonType : function() { return this.property; } }; // 优点验证 let son = new SubType(); console.log(son.age); // 15 console.log(son.getSuperValue()); // false // 缺点验证 let instance1 = new SubType(); instance1.city.push(\"重庆\"); console.log(instance1.city); // [\"北京\", \"上海\", \"天津\", \"重庆\"] let instance2 = new SubType(); console.log(instance2.city); // [\"北京\", \"上海\", \"天津\", \"重庆\"] } // test1(); 构造函数继承 优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点 缺点：父类原型的属性和方法不可复用\nfunction test2() { function SuperType(name) { this.name = name; this.city = [ \"北京\", \"上海\", \"天津\" ] } SuperType.prototype = { constructor : SuperType, age : 18, showInfo : function() { return this.name; } }; function SubType() { // 父类调用call()或者apply()方法和子类共用同一个this，实现子类实例属性的继承 SuperType.call(this, \"张三\"); } // 优点验证 let instance = new SubType(); instance.city.push(\"重庆\"); console.log(instance.city); // [\"北京\", \"上海\", \"天津\", \"重庆\"] let instance1 = new SubType(); console.log(instance1.city); // [\"北京\", \"上海\", \"天津\"] // 缺点验证 console.log(instance.age); // undefined instance.showInfo(); // son.showInfo is not a function } // test2(); 组合继承（推荐） 优点：原型的属性和方法可以复用，每个子类实例都有自己的属性 缺点：父类构造函数调用了两次，子类原型中的父类实例属性被子类实例覆盖\nfunction test3() { function SuperType(name) { this.name = name; this.city = [ \"北京\", \"上海\", \"天津\" ] } SuperType.prototype = { constructor : SuperType, showInfo : function() { console.log(this.name + \"今年\" + this.age + \"岁了\"); } }; function SubType(name, age) { // 1. 通过构造方法继承实现实例属性的继承 SuperType.call(this, name); this.age = age; } // 2. 通过原型链继承实现原型方法的继承 SubType.prototype = new SuperType(); // 优点验证 let instance = new SubType(\"张三\", 15); instance.showInfo(); // 张三今年15岁了 let instance1 = new SubType(); instance1.city.push(\"重庆\"); console.log(instance1.city); // [\"北京\", \"上海\", \"天津\", \"重庆\"] let instance2 = new SubType(); console.log(instance2.city); // [\"北京\", \"上海\", \"天津\"] } // test3(); 寄生组合继承（推荐） 优点：解决了组合继承的缺点，效率高 缺点：基本没有\nfunction test4() { function inheritPrototype(subType, superType) { // 1. 继承父类的原型 var prototype = Object.create(superType.prototype); // 2. 重写被污染的construct prototype.constructor = subType; // 3. 重写子类的原型 subType.prototype = prototype; } function SuperType(name) { this.name = name; this.city = [ \"北京\", \"上海\", \"天津\" ]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age) { SuperType.call(this, name); this.age = age; } // 将父类原型指向子类 inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function() { console.log(this.age); } // 优点验证 let instance = new SubType(\"张三\", 15); instance.sayName(); // 张三 let instance1 = new SubType(); instance1.city.push(\"重庆\"); console.log(instance1.city); // [\"北京\", \"上海\", \"天津\", \"重庆\"] let instance2 = new SubType(); console.log(instance2.city); // [\"北京\", \"上海\", \"天津\"] } // test4(); 4.ES6新方法－－class 新的关键字class在es6开始被引入到javascript中来，class的目的就是让定义类更简单\n用函数方法实现：\nfunction Person(name) { this.name = name; } Person.prototype.hello = function () { console.log('Hello, ' + this.name + '!'); } var son = new Person('xm') son.hello(); // Hello, xm! 用class来实现：\nclass Person { constructor(name) { this.name = name; } hello() { console.log('Hello, ' + this.name + '!'); } } var son = new person('xm') son.hello(); // Hello, xm! 可以在看到，在定义class中，直接包含了构造函数constructor属性，和原型对象上的函数hello()方法，省略掉了function关键字\n需要注意：原来的写法是，构造函数和原型对象分散开来写，现在用class可以直接把两者串在一个对象中，只有最后传参和调用方法时写法是一样的\nclass继承\n用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Person派生一个PrimaryPerson需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：\nclass PrimaryPerson extends Person { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert('I am at grade ' + this.grade); } } 注意PrimaryPerson的定义也是通过class关键字实现的，而extends则表示原型链对象来自Person，子类的构造函数可能会和父类的不太相同\n例如，PrimaryPerson需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。\nPrimaryPerson已经自动获得了父类Person的hello方法，我们又在子类中定义了新的myGrade方法。\nES6引入的class和原有的JavaScript原型继承有什么区别呢？\n实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。\n但是！\n目前并不是所有的浏览器都支持class，所以在选择的时候一定要慎重！\n","wordCount":"900","inLanguage":"en","datePublished":"2020-11-12T12:58:00Z","dateModified":"2020-11-12T12:58:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ioo.gay/posts/2020-11-12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"子舒的博客","logo":{"@type":"ImageObject","url":"https://ioo.gay/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ioo.gay/ accesskey=h title="Home (Alt + H)"><img src=https://ioo.gay/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ioo.gay/categories/ title=categories><span>categories</span></a></li><li><a href=https://ioo.gay/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ioo.gay/>Home</a>&nbsp;»&nbsp;<a href=https://ioo.gay/posts/>Posts</a></div><h1 class=post-title>面向对象编程</h1><div class=post-meta><span title='2020-11-12 12:58:00 +0000 UTC'>November 12, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;900 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。</p><h2 id=一什么是面向对象编程>一、什么是面向对象编程<a hidden class=anchor aria-hidden=true href=#一什么是面向对象编程>#</a></h2><p>js是<code>基于原型</code>的，基于<code>面向对象编程</code></p><p>面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类</p><p><img loading=lazy src=https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/99809398-db39-4c68-97b2-83ff9971f2c6.png alt></p><h3 id=1面向过程程序设计>1.面向过程程序设计<a hidden class=anchor aria-hidden=true href=#1面向过程程序设计>#</a></h3><p>将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。</p><p>自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用</p><p>面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。</p><h3 id=2面向对象程序设计>2.面向对象程序设计<a hidden class=anchor aria-hidden=true href=#2面向对象程序设计>#</a></h3><p>将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统</p><p>面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。</p><p>想要弄明白面向对象，需要先理解类和对象的概念</p><p><a href=../20201118-objects-interfaces-classes>《什么是类和对象？》</a></p><h2 id=二创建对象的方法>二、创建对象的方法<a hidden class=anchor aria-hidden=true href=#二创建对象的方法>#</a></h2><h3 id=1创建字面量和实例>1.创建字面量和实例<a hidden class=anchor aria-hidden=true href=#1创建字面量和实例>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 实例
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>person</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Object</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>person</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=s1>&#39;小明&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>person</span><span class=p>.</span><span class=nx>age</span> <span class=o>=</span> <span class=mi>22</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>person</span><span class=p>.</span><span class=nx>year</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s1>&#39;今年&#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>+</span> <span class=s1>&#39;岁了！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=nx>person</span><span class=p>.</span><span class=nx>year</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 字面量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>student</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;小明&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>age</span><span class=o>:</span> <span class=mi>22</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>year</span><span class=o>:</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s1>&#39;今年&#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>+</span> <span class=s1>&#39;岁了！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>student</span><span class=p>.</span><span class=nx>year</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 小明今年22岁了！
</span></span></span></code></pre></div><p>两者输出的结果是一样的，控制台输出：
<img loading=lazy src=https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/c8eb2a0d-5c3a-461e-b699-79653edcd986.jpg alt></p><blockquote><p>缺点：重复实例化对象，代码冗余高</p></blockquote><h3 id=2工厂模式>2.工厂模式<a hidden class=anchor aria-hidden=true href=#2工厂模式>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>createObj</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>age</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>obj</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Object</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=nx>obj</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>obj</span><span class=p>.</span><span class=nx>age</span> <span class=o>=</span> <span class=nx>age</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>obj</span><span class=p>.</span><span class=nx>year</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s1>&#39;今年&#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>+</span> <span class=s1>&#39;岁了！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>obj</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>obj</span> <span class=o>=</span> <span class=nx>createObj</span><span class=p>(</span><span class=s1>&#39;小明&#39;</span><span class=p>,</span> <span class=mi>22</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>obj</span><span class=p>.</span><span class=nx>year</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote><p>优点：解决重复实例化对象的问题
缺点：无法识别对象的类型，因为所有的实例都指向一个原型</p></blockquote><h3 id=3构造函数>3.构造函数<a hidden class=anchor aria-hidden=true href=#3构造函数>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>Person</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>age</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>=</span> <span class=nx>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>year</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s1>&#39;今年&#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>+</span> <span class=s1>&#39;岁了！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>student</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Person</span><span class=p>(</span><span class=s1>&#39;小明&#39;</span><span class=p>,</span> <span class=mi>22</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>student</span><span class=p>.</span><span class=nx>year</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote><p>优点：可以识别对象的类型
缺点：多个实例重复创建方法，无法共享</p></blockquote><h3 id=4-原型模式>4. 原型模式<a hidden class=anchor aria-hidden=true href=#4-原型模式>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>Par</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>Par</span><span class=p>.</span><span class=nx>prototype</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>constructor</span><span class=o>:</span> <span class=s1>&#39;Par&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;小明&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>age</span><span class=o>:</span> <span class=mi>22</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>year</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s1>&#39;今年&#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>+</span> <span class=s1>&#39;岁了！&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>son</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Par</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>son</span><span class=p>.</span><span class=nx>year</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote><p>缺点：所有实例共享他的属性和方法，不能传参和初始化属性值</p></blockquote><h3 id=5混合模式推荐使用>5.混合模式(推荐使用)<a hidden class=anchor aria-hidden=true href=#5混合模式推荐使用>#</a></h3><p>是构造函数和原型模式混合的写法，拥有各自的优点，构造函数共享实例属性，原型模式共享方法和想要共享的属性，可以传参和初始化属性值</p><p>先用构造函数定义对象的属性方法，然后用原型模式创建方法，使用的属性通过prototype获取，有一个constructor属性，可以指向要操作的函数对象（构造函数）</p><p>比如<code>constructor: Par</code>，就代表下面这个原型方法指向<code>Par()</code>对象（构造函数）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>Par</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>age</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>=</span> <span class=nx>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>Par</span><span class=p>.</span><span class=nx>prototype</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>constructor</span><span class=o>:</span> <span class=nx>Par</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>year</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s1>&#39;今年&#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>+</span> <span class=s1>&#39;岁了！&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>son</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Par</span><span class=p>(</span><span class=s1>&#39;小明&#39;</span><span class=p>,</span> <span class=mi>22</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>son</span><span class=p>.</span><span class=nx>year</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 小明今年22岁了！
</span></span></span></code></pre></div><h2 id=三原型原型链>三、原型，原型链<a hidden class=anchor aria-hidden=true href=#三原型原型链>#</a></h2><h3 id=1原型对象>1.原型对象<a hidden class=anchor aria-hidden=true href=#1原型对象>#</a></h3><ol><li>函数对象都具有<code>prototype</code>属性，它指向函数的原型对象(浏览器内存创建的对象)，原型对象都具有<code>constructor</code>属性，它指向<code>prototype</code>属性所在的函数对象(构造函数)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>Par</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>age</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>=</span> <span class=nx>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>Par</span><span class=p>.</span><span class=nx>prototype</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// constructor指向对象
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>constructor</span><span class=o>:</span> <span class=nx>Par</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>year</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s1>&#39;今年&#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>+</span> <span class=s1>&#39;岁了！&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>son</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Par</span><span class=p>(</span><span class=s1>&#39;小明&#39;</span><span class=p>,</span> <span class=mi>22</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>son</span><span class=p>.</span><span class=nx>year</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*********************************************/</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>Par</span><span class=p>.</span><span class=nx>prototype</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>Par</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>constructor</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=cm>/*********************************************/</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>通过控制台可以看到</p><p>构造函数的<code>prototypr</code>属性指向原型对象</p><p>原型对象的<code>construcyor</code>属性指向构造函数</p><p><img loading=lazy src=https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/769d7f85-0893-4896-84ac-8cb03b8e55d6.jpg alt></p><ol start=2><li>当调用构造函数创建一个实例后，该实例会有一个隐藏属性<code>__proto__ </code>，它指向构造函数的原型对象</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>son</span><span class=p>.</span><span class=nx>__proto__</span> <span class=o>===</span> <span class=nx>Par</span><span class=p>.</span><span class=nx>prototype</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// true
</span></span></span></code></pre></div><ol start=3><li>所有的构造函数的prototype都是object类型</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>typeof</span> <span class=nx>Par</span><span class=p>.</span><span class=nx>prototype</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// object
</span></span></span></code></pre></div><ol start=4><li>Function的prototype是一个空函数，所有内置函数的__proto__属性都指向这个空函数</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>Math</span><span class=p>.</span><span class=nx>__proto__</span><span class=p>)</span>
</span></span></code></pre></div><p><img loading=lazy src=https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/47a21be9-e931-48e5-8724-96e7af58ab85.jpg alt></p><ol start=5><li>如果构造函数实例和原型对象中同时定义了一个属性，在调用时，会屏蔽原型对象中的属性，如果想要访问原型对象中的属性值，需要通过<code>delete</code>方法将同名属性在实例（构造函数）中彻底删除</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>Par</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>Par</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=s2>&#34;张三&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>son</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Par</span><span class=p>(</span><span class=s2>&#34;李四&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>son</span><span class=p>.</span><span class=nx>name</span><span class=p>);</span> <span class=c1>// 李四
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>son</span><span class=p>.</span><span class=nx>__proto__</span><span class=p>.</span><span class=nx>name</span><span class=p>);</span> <span class=c1>// 张三
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用delete删除实例的同名属性值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>delete</span> <span class=nx>son</span><span class=p>.</span><span class=nx>name</span><span class=p>);</span>   <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>son</span><span class=p>.</span><span class=nx>name</span><span class=p>);</span> <span class=c1>// 张三
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ol start=6><li>通过<code>hasOwnProperty(属性名)</code>可以判断一个属性存在于构造函数中，还是原型对象中</li></ol><blockquote><p><code>true</code>表示存在构造函数中；<code>false</code>表示存在原型对象中</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>Par</span><span class=p>.</span><span class=nx>hasOwnProperty</span><span class=p>(</span><span class=nx>name</span><span class=p>));</span>  <span class=c1>// false
</span></span></span></code></pre></div><ol start=7><li>操作符<code>in</code>，可以判断一个属性是否存在（存在于构造函数和原型对象中皆可）</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>Par</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>age</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>=</span> <span class=nx>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>Par</span><span class=p>.</span><span class=nx>prototype</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>constructor</span><span class=o>:</span> <span class=nx>Par</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>year</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>age</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>son</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Par</span><span class=p>(</span><span class=s1>&#39;xm&#39;</span><span class=p>,</span> <span class=s1>&#39;22&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>son</span><span class=p>.</span><span class=nx>year</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;name&#39;</span> <span class=k>in</span> <span class=nx>Par</span><span class=p>);</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;age&#39;</span> <span class=k>in</span> <span class=nx>Par</span><span class=p>);</span>  <span class=c1>// false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>同样的两个属性，判断其是否存在于实例或者原型对象中，输出的结果不一样</p><blockquote><p>参考:《对象中是否有某一个属性 in》<a href=https://www.cnblogs.com/IwishIcould/p/12333739.html>https://www.cnblogs.com/IwishIcould/p/12333739.html</a></p></blockquote><h3 id=2__proto__和prototype的区别>2.__proto__和prototype的区别<a hidden class=anchor aria-hidden=true href=#2__proto__和prototype的区别>#</a></h3><ol><li><p><code>prototype</code>属性只有函数对象上才有，而<code>__proto__</code>属性所有对象都有</p></li><li><p><code>prototype</code>是由函数对象指向原型对象，而<code>__proto__</code>是由实例指向函数对象的原型对象</p></li><li><p>原型链，将父类型的实例作为子类型的原型对象，这种链式关系叫做<code>原型链</code></p></li></ol><p><img loading=lazy src=https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/ed2c179f-0e9d-4da0-bae3-00d2273b10c6.png alt></p><h3 id=3继承>3.继承<a hidden class=anchor aria-hidden=true href=#3继承>#</a></h3><ol><li>原型链继承</li></ol><blockquote><p>优点：父类原型定义的属性和方法可以复用
缺点：子类实例没有自己的属性，不能向父类传递参数</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>test1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>SuperType</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>city</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>&#34;北京&#34;</span><span class=p>,</span> <span class=s2>&#34;上海&#34;</span><span class=p>,</span> <span class=s2>&#34;天津&#34;</span> <span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>property</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>SuperType</span><span class=p>.</span><span class=nx>prototype</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>constructor</span> <span class=o>:</span> <span class=nx>SuperType</span><span class=p>,</span>     <span class=c1>// 保持构造函数和原型对象的完整性
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>age</span> <span class=o>:</span> <span class=mi>15</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>getSuperValue</span> <span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>property</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>SonType</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>property</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 重写子类的原型指向父类的实例：继承父类的原型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>SubType</span><span class=p>.</span><span class=nx>prototype</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SuperType</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>SubType</span><span class=p>.</span><span class=nx>prototype</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>constructor</span> <span class=o>:</span> <span class=nx>SubType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>getSonType</span> <span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>property</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 优点验证
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>let</span> <span class=nx>son</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SubType</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>son</span><span class=p>.</span><span class=nx>age</span><span class=p>);</span> <span class=c1>// 15
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>son</span><span class=p>.</span><span class=nx>getSuperValue</span><span class=p>());</span> <span class=c1>// false
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 缺点验证
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>let</span> <span class=nx>instance1</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SubType</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>instance1</span><span class=p>.</span><span class=nx>city</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=s2>&#34;重庆&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>instance1</span><span class=p>.</span><span class=nx>city</span><span class=p>);</span> <span class=c1>// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>instance2</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SubType</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>instance2</span><span class=p>.</span><span class=nx>city</span><span class=p>);</span> <span class=c1>// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// test1();
</span></span></span></code></pre></div><ol start=2><li>构造函数继承</li></ol><blockquote><p>优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点
缺点：父类原型的属性和方法不可复用</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>test2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>SuperType</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>city</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>&#34;北京&#34;</span><span class=p>,</span> <span class=s2>&#34;上海&#34;</span><span class=p>,</span> <span class=s2>&#34;天津&#34;</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>SuperType</span><span class=p>.</span><span class=nx>prototype</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>constructor</span> <span class=o>:</span> <span class=nx>SuperType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>age</span> <span class=o>:</span> <span class=mi>18</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>showInfo</span> <span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>SubType</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 父类调用call()或者apply()方法和子类共用同一个this，实现子类实例属性的继承
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>SuperType</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=s2>&#34;张三&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 优点验证
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>let</span> <span class=nx>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SubType</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>instance</span><span class=p>.</span><span class=nx>city</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=s2>&#34;重庆&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>instance</span><span class=p>.</span><span class=nx>city</span><span class=p>);</span> <span class=c1>// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>instance1</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SubType</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>instance1</span><span class=p>.</span><span class=nx>city</span><span class=p>);</span> <span class=c1>// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 缺点验证
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>instance</span><span class=p>.</span><span class=nx>age</span><span class=p>);</span> <span class=c1>// undefined
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>instance</span><span class=p>.</span><span class=nx>showInfo</span><span class=p>();</span> <span class=c1>// son.showInfo is not a function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// test2();
</span></span></span></code></pre></div><ol start=3><li>组合继承（推荐）</li></ol><blockquote><p>优点：原型的属性和方法可以复用，每个子类实例都有自己的属性
缺点：父类构造函数调用了两次，子类原型中的父类实例属性被子类实例覆盖</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>test3</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>SuperType</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>city</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>&#34;北京&#34;</span><span class=p>,</span> <span class=s2>&#34;上海&#34;</span><span class=p>,</span> <span class=s2>&#34;天津&#34;</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>SuperType</span><span class=p>.</span><span class=nx>prototype</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>constructor</span> <span class=o>:</span> <span class=nx>SuperType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>showInfo</span> <span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s2>&#34;今年&#34;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>+</span> <span class=s2>&#34;岁了&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>SubType</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>age</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 1. 通过构造方法继承实现实例属性的继承
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>SuperType</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=nx>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>=</span> <span class=nx>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 通过原型链继承实现原型方法的继承
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>SubType</span><span class=p>.</span><span class=nx>prototype</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SuperType</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 优点验证
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>let</span> <span class=nx>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SubType</span><span class=p>(</span><span class=s2>&#34;张三&#34;</span><span class=p>,</span> <span class=mi>15</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>instance</span><span class=p>.</span><span class=nx>showInfo</span><span class=p>();</span> <span class=c1>// 张三今年15岁了
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>instance1</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SubType</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>instance1</span><span class=p>.</span><span class=nx>city</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=s2>&#34;重庆&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>instance1</span><span class=p>.</span><span class=nx>city</span><span class=p>);</span> <span class=c1>// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>instance2</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SubType</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>instance2</span><span class=p>.</span><span class=nx>city</span><span class=p>);</span> <span class=c1>// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// test3();
</span></span></span></code></pre></div><ol start=4><li>寄生组合继承（推荐）</li></ol><blockquote><p>优点：解决了组合继承的缺点，效率高
缺点：基本没有</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>test4</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>inheritPrototype</span><span class=p>(</span><span class=nx>subType</span><span class=p>,</span> <span class=nx>superType</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 1. 继承父类的原型
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>var</span> <span class=nx>prototype</span> <span class=o>=</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>create</span><span class=p>(</span><span class=nx>superType</span><span class=p>.</span><span class=nx>prototype</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 2. 重写被污染的construct
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>prototype</span><span class=p>.</span><span class=nx>constructor</span> <span class=o>=</span> <span class=nx>subType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 3. 重写子类的原型
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>subType</span><span class=p>.</span><span class=nx>prototype</span> <span class=o>=</span> <span class=nx>prototype</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>SuperType</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>city</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>&#34;北京&#34;</span><span class=p>,</span> <span class=s2>&#34;上海&#34;</span><span class=p>,</span> <span class=s2>&#34;天津&#34;</span> <span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>SuperType</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>sayName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>SubType</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>age</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>SuperType</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=nx>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>age</span> <span class=o>=</span> <span class=nx>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 将父类原型指向子类
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>inheritPrototype</span><span class=p>(</span><span class=nx>SubType</span><span class=p>,</span> <span class=nx>SuperType</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>SubType</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>sayAge</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>age</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 优点验证
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>let</span> <span class=nx>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SubType</span><span class=p>(</span><span class=s2>&#34;张三&#34;</span><span class=p>,</span> <span class=mi>15</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>instance</span><span class=p>.</span><span class=nx>sayName</span><span class=p>();</span> <span class=c1>// 张三
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>instance1</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SubType</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>instance1</span><span class=p>.</span><span class=nx>city</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=s2>&#34;重庆&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>instance1</span><span class=p>.</span><span class=nx>city</span><span class=p>);</span> <span class=c1>// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>instance2</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SubType</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>instance2</span><span class=p>.</span><span class=nx>city</span><span class=p>);</span> <span class=c1>// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// test4();
</span></span></span></code></pre></div><h3 id=4es6新方法class>4.ES6新方法－－class<a hidden class=anchor aria-hidden=true href=#4es6新方法class>#</a></h3><p>新的关键字<code>class</code>在es6开始被引入到javascript中来，<code>class</code>的目的就是让定义类更简单</p><p>用函数方法实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Person</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>Person</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>hello</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Hello, &#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s1>&#39;!&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>son</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Person</span><span class=p>(</span><span class=s1>&#39;xm&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>son</span><span class=p>.</span><span class=nx>hello</span><span class=p>();</span>    <span class=c1>// Hello, xm!
</span></span></span></code></pre></div><p>用<code>class</code>来实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>class</span> <span class=nx>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>constructor</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>hello</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Hello, &#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s1>&#39;!&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>son</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>person</span><span class=p>(</span><span class=s1>&#39;xm&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>son</span><span class=p>.</span><span class=nx>hello</span><span class=p>();</span>    <span class=c1>// Hello, xm!
</span></span></span></code></pre></div><p>可以在看到，在定义<code>class</code>中，直接包含了构造函数<code>constructor</code>属性，和原型对象上的函数<code>hello()</code>方法，省略掉了<code>function</code>关键字</p><p>需要注意：原来的写法是，构造函数和原型对象分散开来写，现在用<code>class</code>可以直接把两者串在一个对象中，只有最后传参和调用方法时写法是一样的</p><p><strong>class继承</strong></p><p>用<code>class</code>定义对象的另一个巨大的好处是继承更方便了。想一想我们从<code>Person</code>派生一个<code>PrimaryPerson</code>需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过<code>extends</code>来实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>class</span> <span class=nx>PrimaryPerson</span> <span class=kr>extends</span> <span class=nx>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>constructor</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>grade</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>super</span><span class=p>(</span><span class=nx>name</span><span class=p>);</span> <span class=c1>// 记得用super调用父类的构造方法!
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=nx>grade</span> <span class=o>=</span> <span class=nx>grade</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>myGrade</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>alert</span><span class=p>(</span><span class=s1>&#39;I am at grade &#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>grade</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意<code>PrimaryPerson</code>的定义也是通过class关键字实现的，而<code>extends</code>则表示原型链对象来自<code>Person</code>，子类的构造函数可能会和父类的不太相同</p><p>例如，<code>PrimaryPerson</code>需要<code>name</code>和<code>grade</code>两个参数，并且需要通过<code>super(name)</code>来调用父类的构造函数，否则父类的<code>name</code>属性无法正常初始化。</p><p><code>PrimaryPerson</code>已经自动获得了父类<code>Person</code>的<code>hello方法</code>，我们又在子类中定义了新的<code>myGrade</code>方法。</p><p>ES6引入的<code>class</code>和原有的<code>JavaScript原型继承</code>有什么区别呢？</p><p>实际上它们没有任何区别，<code>class</code>的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用<code>class</code>的好处就是极大地简化了原型链代码。</p><p>但是！</p><p>目前并不是所有的浏览器都支持<code>class</code>，所以在选择的时候一定要慎重！</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ioo.gay/tags/%E7%BC%96%E7%A8%8B/>编程</a></li><li><a href=https://ioo.gay/tags/js/>js</a></li></ul><nav class=paginav><a class=prev href=https://ioo.gay/posts/2020-11-13-%E4%B8%BA%E4%BB%80%E4%B9%88gettime%E8%BF%94%E5%9B%9E1970%E5%B9%B4%E8%87%B3%E4%BB%8A%E7%9A%84%E6%AF%AB%E7%A7%92/><span class=title>« Prev</span><br><span>为什么getTime()返回1970年至今的毫秒？</span></a>
<a class=next href=https://ioo.gay/posts/2020-11-09-%E5%B0%8F%E5%BC%A0%E5%8E%A8%E6%88%BF%E6%97%A5%E8%AE%B0%E6%9B%B4%E6%96%B0%E4%B8%AD.../><span class=title>Next »</span><br><span>小张厨房日记（更新中...）</span></a></nav><script src=https://giscus.app/client.js data-repo=zburu/hugo-blog data-repo-id=R_kgDOHwNIPQ data-category=Announcements data-category-id=DIC_kwDOHwNIPc4CRsQ1 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象编程 on twitter" href="https://twitter.com/intent/tweet/?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b&url=https%3a%2f%2fioo.gay%2fposts%2f2020-11-12-%25E9%259D%25A2%25E5%2590%2591%25E5%25AF%25B9%25E8%25B1%25A1%25E7%25BC%2596%25E7%25A8%258B%2f&hashtags=%e7%bc%96%e7%a8%8b%2cjs"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象编程 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fioo.gay%2fposts%2f2020-11-12-%25E9%259D%25A2%25E5%2590%2591%25E5%25AF%25B9%25E8%25B1%25A1%25E7%25BC%2596%25E7%25A8%258B%2f&title=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b&summary=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b&source=https%3a%2f%2fioo.gay%2fposts%2f2020-11-12-%25E9%259D%25A2%25E5%2590%2591%25E5%25AF%25B9%25E8%25B1%25A1%25E7%25BC%2596%25E7%25A8%258B%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象编程 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fioo.gay%2fposts%2f2020-11-12-%25E9%259D%25A2%25E5%2590%2591%25E5%25AF%25B9%25E8%25B1%25A1%25E7%25BC%2596%25E7%25A8%258B%2f&title=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象编程 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fioo.gay%2fposts%2f2020-11-12-%25E9%259D%25A2%25E5%2590%2591%25E5%25AF%25B9%25E8%25B1%25A1%25E7%25BC%2596%25E7%25A8%258B%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象编程 on whatsapp" href="https://api.whatsapp.com/send?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b%20-%20https%3a%2f%2fioo.gay%2fposts%2f2020-11-12-%25E9%259D%25A2%25E5%2590%2591%25E5%25AF%25B9%25E8%25B1%25A1%25E7%25BC%2596%25E7%25A8%258B%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象编程 on telegram" href="https://telegram.me/share/url?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b&url=https%3a%2f%2fioo.gay%2fposts%2f2020-11-12-%25E9%259D%25A2%25E5%2590%2591%25E5%25AF%25B9%25E8%25B1%25A1%25E7%25BC%2596%25E7%25A8%258B%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://ioo.gay/>子舒的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>