<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>技术 | 子舒的博客</title><meta name=keywords content><meta name=description content="不如吃茶去"><meta name=author content="Me"><link rel=canonical href=https://zburu.vercel.app/categories/%E6%8A%80%E6%9C%AF/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><link rel=icon href=https://zburu.vercel.app/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://zburu.vercel.app/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://zburu.vercel.app/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://zburu.vercel.app/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://zburu.vercel.app/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://zburu.vercel.app/categories/%E6%8A%80%E6%9C%AF/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="技术"><meta property="og:description" content="不如吃茶去"><meta property="og:type" content="website"><meta property="og:url" content="https://zburu.vercel.app/categories/%E6%8A%80%E6%9C%AF/"><meta property="og:image" content="https://zburu.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="不如吃茶去"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zburu.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="技术"><meta name=twitter:description content="不如吃茶去"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zburu.vercel.app accesskey=h title="Home (Alt + H)"><img src=https://zburu.vercel.app/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zburu.vercel.app/categories/ title=categories><span>categories</span></a></li><li><a href=https://zburu.vercel.app/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://zburu.vercel.app>Home</a>&nbsp;»&nbsp;<a href=https://zburu.vercel.app/categories/>Categories</a></div><h1>技术
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>ES5 和 ES6 的区别？</h2></header><div class=entry-content><p>一、javascript 由三部分组成 1.ECMAScript（核心） 它规定了语言的组成部分：法语，类型，语句，关键字，操作符等等。
2.DOM（文档对象模型） DOM 把整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。
3.BOM（浏览器对象模型） 支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。
二、什么是ES5？ 作为ECMAScript第五个版本（第四版因为过于复杂废弃了），浏览器支持情况可看第一副图，增加特性如下。
1.strict模式 严格模式，限制一些用法，‘use strict’;
2.Array增加方法 增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法
PS： 还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now
3.Object方法 Object.getPrototypeOf Object.create Object.getOwnPropertyNames Object.defineProperty Object.getOwnPropertyDescriptor Object.defineProperties Object.keys Object.preventExtensions / Object.isExtensible Object.seal / Object.isSealed Object.freeze / Object.isFrozen PS：只讲有什么，不讲是什么。
2.什么是ES6? ECMAScript6在保证向下兼容的前提下，提供大量新特性，目前浏览器兼容情况如下：
ES6特性如下：
块级作用域 关键字let, 常量const
对象字面量的属性赋值简写（property value shorthand）
var obj = { // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Method definitions toString() { // Super calls return "d " + super....</p></div><footer class=entry-footer><span title='2021-01-20 19:58:00 +0000 UTC'>January 20, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;712 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ES5 和 ES6 的区别？" href=https://zburu.vercel.app/posts/2021-01-20-es5_%E5%92%8C_es6_%E7%9A%84%E5%8C%BA%E5%88%AB_/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>webpack 的核心概念和构建流程</h2></header><div class=entry-content><p>1.webpack 的核心概念 entry（入口）：一个可执行模块或者库的入口。定义了打包后的入口文件。 output（出口）：指示 webpack 如何去输出，以及在哪里输出。 path: 打包文件存放的绝对路径 publicPath: 网站运行时的访问路径 filename: 打包后的文件名 module（模块）：在 webpack 里，一切皆模块，一个模块对应一个文件。webpack 会从配置的 entry 中开始递归找出所有依赖的模块。 chunk（代码块）：一个 chunk 由多个 模块 组合而成。可以将可执行的模块和他所依赖的模块组合成一个 chunk ，这就是打包。 loader（模块转换器）：用于把一个模块原内容按照需求转换成新的内容。例如：es6 转换为 es5，scss 转换为 css 等。 plugin（扩展）：扩展webpack功能的插件。在webpack构建的生命周期节点上加入扩展hook，添加功能。 2.webpack 构建流程 初始化参数：解析 webpack 的配置参数，合并 shell 传入和 webpack.config.js 文件配置的参数，形成最后的配置结果。 开始编译：上一步得到的参数初始化 compiler 对象，注册所有配置的插件，插件监听 webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。 确定入口：其配置的 entry 入口，开始解析文件构建的 AST 语法树，找出依赖，递归下去。 编译模块：根据文件类型和 loader 配置，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理。 完成模块编译并输出：递归完后，得到每个文件结果，包含了每个模块及她们之间的依赖关系，根据 entry 配置生成代码块 chunk 。 输出完成：输出所有的 chunk 到文件系统。 3.有哪些常见的 loader ？ babel-loader：把es6转成es5； css-loader：加载css，支持模块化，压缩，文件导入等特性； style-loader：把css代码注入到js中，通过dom操作去加载css； eslint-loader：通过Eslint检查js代码； image-loader：加载并且压缩图片晚间； file-loader：文件输出到一个文件夹中，在代码中通过相对url去引用输出的文件； url-loader：和file-loader类似，文件很小的时候可以base64方式吧文件内容注入到代码中。 source-map-loader：加载额外的source map文件，方便调试。 4....</p></div><footer class=entry-footer><span title='2021-01-18 19:59:00 +0000 UTC'>January 18, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;361 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to webpack 的核心概念和构建流程" href=https://zburu.vercel.app/posts/2021-01-18-webpack_%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>基于 React 的富文本编辑器－－Braft Editor</h2></header><div class=entry-content><p>最近发了很多关于 React 的文章，记录遇到的新技术点，以及在写代码过程中遇到的问题，希望可以帮助到和我遇到同样问题的同学。
今天分享的是一款基于 React 的富文本编辑器－－Braft Editor。
Braft Editor 官网：https://braft.margox.cn Github 仓库地址：https://github.com/margox/braft-editor
这款插件非常方便，只需要下载然后引入即可直接使用，页面整体风格清新，符合绝大多数人的审美观，支持图片，音视频的插入。
按照官方的说法，假如你对它的功能还不够满意，不够使用，完全可以扩展它，自己写一个插件来强化他。
经过我的测试，功能绝对强大，可以满足市面上绝大多数的需求。接下来就说一下如何使用这款插件。
1.安装 在项目中直接通过 npm 或者 yarn 下载插件：
# 使用 npm 安装 npm install braft-editor --save # 使用 yarn 安装 yarn add braft-editor 2.使用 新建一个组件 EditorDemo.js，在里面写入下列代码：
// EditorDemo.js import React from 'react'; import BraftEditor from 'braft-editor'; import 'braft-editor/dist/index.css'; export default class PageDemo extends React.Component { state = { editorState: BraftEditor.createEditorState(null) } render () { return ( &lt;BraftEditor value={this....</p></div><footer class=entry-footer><span title='2021-01-07 20:46:00 +0000 UTC'>January 7, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;98 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 基于 React 的富文本编辑器－－Braft Editor" href=https://zburu.vercel.app/posts/2021-01-07-%E5%9F%BA%E4%BA%8E_react_%E7%9A%84%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8braft_editor/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>使用 React 与 Vue 创建同一款 App，差别究竟有多大？</h2></header><div class=entry-content><p>关于 React 框架 和 Vue 框架 的对比，用两者写出同一个程序，对比其代码实现的过程，看看它们的差异究竟有多大？
转载于：https://blog.csdn.net/csdnnews/article/details/81880378 原文：https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd 作者简介：Sunil Sandhu，一位 Web 全栈工程师 + 空想家。 译者：安翔，责编：屠敏
众所周知，Vue 和 React 都是目前非常著名的前端框架。我在工作中经常使用 Vue，因此我对它有很深入的了解。同时，我也对 React 充满了好奇，想要学习一下，一探究竟。
于是我阅读了 React 文档并观看了一些视频教程，虽然这些资料很不错，但是我真正想了解的是 React 与 Vue 之间的不同之处。所谓“不同之处”，我并非想知道它们是否都具有虚拟 DOMS 或者它们如何渲染页面，而是希望有人能够从代码的角度解释这两者之间的差异。我想找到一篇解释这些差异的文章，以便 Vue 或者 React 的初学者可以更好地理解它们两者之间的差异。
很遗憾，我并未找到一篇这样的文章。于是我意识到必须自己动手来比较 Vue 与 React 之间的异同。在我自力更生的过程中，我用这篇文章记录下了具体过程。
1.目标 我将会构建一个标准的待办事项应用程序，允许用户添加和删除列表中的项目。这两个应用程序都使用默认的 CLI（command-line interface，命令行界面） 构建，React 使用 create-react-app，Vue 使用 vue-cli。
两个应用程序的外观如下：
两个应用程序的 CSS 代码几乎一样，但这些代码的位置存在差异。考虑到这一点，我们来看看这两个应用程序的文件结构：
你会发现它们的结构几乎完全相同。唯一的区别在于 React App 拥有三个 CSS 文件，而 Vue App 中没有 CSS 文件。这是因为 React 的 create-react-app 组件需要一个附带文件来保存其样式，而 Vue CLI 采用全包方法，其样式在实际组件文件中声明。...</p></div><footer class=entry-footer><span title='2021-01-06 20:47:00 +0000 UTC'>January 6, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;512 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 使用 React 与 Vue 创建同一款 App，差别究竟有多大？" href=https://zburu.vercel.app/posts/2021-01-06-%E4%BD%BF%E7%94%A8_react_%E4%B8%8E_vue_%E5%88%9B%E5%BB%BA%E5%90%8C%E4%B8%80%E6%AC%BE_app%E5%B7%AE%E5%88%AB%E7%A9%B6%E7%AB%9F%E6%9C%89%E5%A4%9A%E5%A4%A7/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>React 脚手架项目打包时的路径问题</h2></header><div class=entry-content><p>create-react-app 脚手架指令可以生成 React 项目，在项目完成之后执行打包命令 npm run build，文件夹内生成 build文件夹，就是打包后的文件，在浏览器运行 index.html 发现页面空白，打开控制台有报错，css 和 js 文件的引用路径有问题。
浏览 index.html 代码可以发现：
&lt;!-- index.html --> &lt;!doctype html> &lt;html lang="zh"> &lt;head> &lt;meta charset="utf-8" /> &lt;meta name="viewport" content="width=device-width,initial-scale=1" /> &lt;meta name="theme-color" content="#000000" /> &lt;meta name="description" content="Web site created using create-react-app" /> &lt;title>React App&lt;/title> &lt;link href="/static/css/main.3394d54e.chunk.css" rel="stylesheet"> &lt;/head> &lt;body>&lt;noscript>You need to enable JavaScript to run this app.&lt;/noscript> &lt;div id="root">&lt;/div> &lt;script>!function (e) { function r(r) { for (var n, l, f = r[0], i = r[1], a = r[2], c = 0, s = []; c &lt; f....</p></div><footer class=entry-footer><span title='2021-01-05 20:54:00 +0000 UTC'>January 5, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;464 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to React 脚手架项目打包时的路径问题" href=https://zburu.vercel.app/posts/2021-01-05-react_%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%97%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>如何在 React 中引入 less？</h2></header><div class=entry-content><p>本文主要写如何在 React 中引入 less 。因为 less 和 css 非常像，因此很容易学习。而且 less 仅对 css 语言增加了少许方便的扩展，这就是 less 如此易学的原因之一。
1.安装 less npm install less less-loader --save-dev 2.暴露 webpack 文件 利用 npx create-react-app 搭建的 React 项目，默认隐藏 webpack 配置文件，引入 less 需要修改 webpack 配置文件，因此我们需要执行命令暴露 webpack 配置文件。
这里需要注意，一旦暴露，无法回退。
npm run eject 如果这一步失败，执行下列命令：
git add . git commit -m "init" 然后再执行 npm run eject
注意：暴露 webpack 文件只能在 create-react-app 之初，一旦项目结构发生改变，再进行暴露操作就会失败。所以尽量在项目建立时就进行 npm run eject 操作。
3.修改 wenpack.config.js 配置 在合适的位置添加：
// 放在 // const sassRegex = /\....</p></div><footer class=entry-footer><span title='2021-01-04 20:50:00 +0000 UTC'>January 4, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;196 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 如何在 React 中引入 less？" href=https://zburu.vercel.app/posts/2021-01-04-%E5%A6%82%E4%BD%95%E5%9C%A8_react_%E4%B8%AD%E5%BC%95%E5%85%A5_less_/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>为什么 key 是必须的？</h2></header><div class=entry-content><p>之前有说到，在 React 中渲染列表的时候，要给每一个数据加一个 key 值，赋予一个确定的标示，而且也详细描述了如何给一个标示，方法知道了，那么为什么要这么做呢？
在 React 中如何渲染列表？
在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。
在子元素列表末尾新增元素时，更新开销比较小。比如：
&lt;ul> &lt;li>first&lt;/li> &lt;li>second&lt;/li> &lt;/ul> &lt;ul> &lt;li>first&lt;/li> &lt;li>second&lt;/li> &lt;li>third&lt;/li> &lt;/ul> React 会先匹配两个 &lt;li>first&lt;/li> 对应的树，然后匹配第二个元素 &lt;li>second&lt;/li> 对应的树，最后插入第三个元素的 &lt;li>third&lt;/li> 树。
如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：
&lt;ul> &lt;li>Duke&lt;/li> &lt;li>Villanova&lt;/li> &lt;/ul> &lt;ul> &lt;li>Connecticut&lt;/li> &lt;li>Duke&lt;/li> &lt;li>Villanova&lt;/li> &lt;/ul> React 不会意识到应该保留 &lt;li>Duke&lt;/li> 和 &lt;li>Villanova&lt;/li>，而是会重建每一个子元素 。这种情况会带来性能问题。
key
为了解决上述问题， React 支持 key 属性，当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下例子在新增 key 之后使得之前的低效转换变得高效：
&lt;ul> &lt;li key="1">Duke&lt;/li> &lt;li key="2">Villanova&lt;/li> &lt;/ul> &lt;ul> &lt;li key="0">Connecticut&lt;/li> &lt;li key="1">Duke&lt;/li> &lt;li key="2">Villanova&lt;/li> &lt;/ul> 现在 React 知道只有带着 '0' key 的元素是新元素，带着 '1' 以及 '2' key 的元素仅仅移动了。...</p></div><footer class=entry-footer><span title='2021-01-01 20:48:00 +0000 UTC'>January 1, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;111 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 为什么 key 是必须的？" href=https://zburu.vercel.app/posts/2021-01-01-%E4%B8%BA%E4%BB%80%E4%B9%88_key_%E6%98%AF%E5%BF%85%E9%A1%BB%E7%9A%84/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://zburu.vercel.app/categories/%E6%8A%80%E6%9C%AF/page/8/>«&nbsp;Prev&nbsp;</a>
<a class=next href=https://zburu.vercel.app/categories/%E6%8A%80%E6%9C%AF/page/10/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://zburu.vercel.app>子舒的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>