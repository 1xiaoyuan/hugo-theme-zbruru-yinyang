<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>技术 | 不如吃茶去</title><meta name=keywords content><meta name=description content="ExampleSite description"><meta name=author content="Me"><link rel=canonical href=https://zburu-hugo.vercel.app/categories/%E6%8A%80%E6%9C%AF/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.285a6d39de26755a140b46b55c249a392c0a40e73c1799942dbb6d5383d9f72f.css integrity="sha256-KFptOd4mdVoUC0a1XCSaOSwKQOc8F5mULbttU4PZ9y8=" rel="preload stylesheet" as=style><link rel=icon href=https://img.zburu.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://img.zburu.com/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://img.zburu.com/favicon.ico><link rel=apple-touch-icon href=https://img.zburu.com/favicon.ico><link rel=mask-icon href=https://img.zburu.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://zburu-hugo.vercel.app/categories/%E6%8A%80%E6%9C%AF/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="技术"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://zburu-hugo.vercel.app/categories/%E6%8A%80%E6%9C%AF/"><meta property="og:image" content="https://zburu-hugo.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zburu-hugo.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="技术"><meta name=twitter:description content="ExampleSite description"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zburu-hugo.vercel.app accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zburu-hugo.vercel.app/categories/ title=categories><span>categories</span></a></li><li><a href=https://zburu-hugo.vercel.app/tags/ title=tags><span>tags</span></a></li><li><a href=https://zburu-hugo.vercel.app/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://zburu-hugo.vercel.app/about/ title=about><span>about</span></a></li><li><a href=https://github.com/zburu title=github><span>github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://zburu-hugo.vercel.app>Home</a>&nbsp;»&nbsp;<a href=https://zburu-hugo.vercel.app/categories/>Categories</a></div><h1>技术
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>react学习路径－－怎么学习react？</h2></header><div class=entry-content><p>转载于:https://github.com/petehunt/react-howto，react开源作者对于react框架的一个学习路径的建议，个人感觉还是相当不错的学习路线
如何学习React? 如果你是一个 React (或者前端) 新手, 出于以下的原因, 你可能会对这个生态圈感到困惑:
React 的目标群体历来是喜欢尝试新事物的开发者和前端专家. Facebook 开源的内容是应用在他们的实际应用中, 因此他们没有关注那些比 Facebook 小的工程需求. 现有的 React 指引水平参差不齐. 在本文中, 我会假设你已有使用 HTML, CSS 和 JavaScript 开发网页的基础.
为什么要听我的? 关于 React, 现在已经有大量的相互冲突的建议了, 为什么要听我的?
因为我是在 Facebook 构建并开源 React 的最初成员之一. 现在我离开了 Facebook 并加入了一家初创公司, 所以我也不会站在 Facebook 的立场上来表态.
如何踏入 React 生态圈 所有的软件都是建立在某个技术栈之上的, 你需要对整个技术栈有足够深入的理解, 才能建造你的应用. 为什么 React 生态圈的工具似乎总让人感觉压力山大呢, 因为它总是以错误的顺序被解释:
你应该按照以下的顺序进行学习, 而不是跳着学或者同时学习:
React npm JavaScript “打包工具” ES6 Routing Flux 你不需要把这些都学完才去使用 React. 只需要在你遇到问题需要解决的时候, 才进入下一步的学习.
另外, 在 React 社区中, 有一些前沿主题是经常被提及到的, 以下的这些主题很有意思, 但也很难弄懂, 所以它们远没有上面的主题流行, 大多数应用也不需要用到这些....</p></div><footer class=entry-footer><span title='2020-11-19 13:02:00 +0000 UTC'>November 19, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;460 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to react学习路径－－怎么学习react？" href=https://zburu-hugo.vercel.app/posts/20201119/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>在js中运算不能随便把value属性定义成变量</h2></header><div class=entry-content><p>在写一个小demo的时候，无意中发现定义变量的时候直接写入value，会导致获取不到数据，或者获取的不是我们想要的内容，在js中运算不能随便把value属性定义成变量
先看一段代码
&lt;input type="text"" id="a"> &lt;span>*&lt;/span> &lt;input type="text" id="b"> &lt;input type="button" value="=" onclick="beto()"> &lt;input type="text" id="sub" disabled> &lt;script> function beto() { var a = document.getElementById('a').value var b = document.getElementById('b').value var sub = document.getElementById('sub').value sub = a + b } &lt;/script> 就这么一看，逻辑貌似没有问题，获取a和b的value，乘法运算，然后输出sub
但是放在浏览器运行的时候，发现完全没有反应
为什么呢？
（假装思考五分钟…）
因为sub.value不能直接定义在变量中
// 先定义id为sub的input框 var sub = document.getElementById('sub') // 然后在运算的时候在直接使用sub.value sub.value = a * b 顺手放一个写demo时候用的简易计算器
&lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>简易计算器&lt;/title> &lt;/head> &lt;body> &lt;input type="text"" id="a"> &lt;select id="c"> &lt;option value="+">+&lt;/option> &lt;option value="-">-&lt;/option> &lt;option value="*">*&lt;/option> &lt;option value="/">/&lt;/option> &lt;/select> &lt;input type="text" id="b"> &lt;input type="button" value="=" onclick="beto()"> &lt;input type="text" id="sub" disabled> &lt;script> function beto() { var a = document....</p></div><footer class=entry-footer><span title='2020-11-18 13:00:00 +0000 UTC'>November 18, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;153 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 在js中运算不能随便把value属性定义成变量" href=https://zburu-hugo.vercel.app/posts/20201118/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>事件监听函数，以及事件的捕获和冒泡机制</h2></header><div class=entry-content><p>事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件，事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为DOM事件流
函数事件 事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件
事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为DOM事件流
true是捕获，false是冒泡，默认为冒泡事件
1.addEventListener()－－添加事件监听函数 给元素添加一个事件，假如有多个事件，不会覆盖，会依次执行
&lt;div id="demo">dom&lt;/div> &lt;script> document.getElementById('demo').addEventListener("click", myfun) document.getElementById('demo').addEventListener("click", myfun1) function myfun() { console.log('事件监听函数') } function myfun1() { console.log('addEventListener') } &lt;/script> 注意： 1.这里有一个细节，addEventListener()里面有两个参数，第一个表示触发的条件，第二个表示触发的事件 正常情况下，第二个参数直接写函数名并且不加参数()，如果加了参数()则表示立即执行，不需要触发第一个参数要求的条件
2.在这里绑定事件的时候，事件名不能和定义的变量名一样，否则无效
2.removeEventListener()－－移除事件监听函数 下面这个demo，当鼠标在div中移动的时候，出现随机数，点击按钮后，移除事件监听函数
&lt;!-- css --> &lt;style> #demo { width: 100px; height: 100px; border: 1px solid #000; } &lt;/style> &lt;!-- html --> &lt;div id="demo">&lt;/div> &lt;input type="button" value="点击移除" onclick="remove()"> &lt;div id="show">&lt;/div> &lt;!-- js --> &lt;script> document.getElementById('demo').addEventListener("mousemove", myfun) function myfun() { document.getElementById('show').innerHTML = Math.random() } function remove() { document....</p></div><footer class=entry-footer><span title='2020-11-17 13:00:00 +0000 UTC'>November 17, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;300 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 事件监听函数，以及事件的捕获和冒泡机制" href=https://zburu-hugo.vercel.app/posts/20201117/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>getElementBy系列和querySelector系列的区别</h2></header><div class=entry-content><p>querySelector和querySelectorAll的用法和getElementBy大致一样，获取的时候带上符号，getElementBy获取的是元素的动态集合，querySelector获取的是元素的静态集合。
但是需要注意：getElementBy系列和querySelector系列的区别
比如，我们写一个for循环，每次获取li标签的时候，ul生成一个li子元素
&lt;ul id="ul"> &lt;li>a&lt;/li> &lt;li>b&lt;/li> &lt;li>c&lt;/li> &lt;/ul> &lt;script> var ul = document.getElementById('ul'); var li = document.getElementsByTagName('li'); for(var i = 0;i &lt; li.length; i++) { ul.appendChild(document.createElement('li')) }; console.log(li.length); // 陷入死循环 &lt;/script> 用i &lt; li.length来进行判断时，会导致浏览器死循环，因为循环一次的时候，浏览器又重新获取li标签数组，每调用一次就会重新对文档进行查询，就会进入死循环
进行修改：把i &lt; li.length改成i &lt; 3，把li标签数组静态化，然后打印
conosle.log(li.length) // 6 重新用querySelector获取一遍元素
&lt;ul id="ul"> &lt;li>a&lt;/li> &lt;li>b&lt;/li> &lt;li>c&lt;/li> &lt;/ul> &lt;script> var ul = document.querySelector('ul'); var li = document.querySelectorAll('li'); for(var i = 0;i&lt;li.length;i++) { ul.appendChild(document.createElement('li')) }; console.log(li.length); // 输出对结果是原来的li.length = 3，而不是增加后的 6 &lt;/script> 静态集合体现在querySelectorAll('li')获取到ul里所有li后，不管后续再动态添加了多少li，都是不会对其参数影响</p></div><footer class=entry-footer><span title='2020-11-16 12:59:00 +0000 UTC'>November 16, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;74 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to getElementBy系列和querySelector系列的区别" href=https://zburu-hugo.vercel.app/posts/20201116/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>DOM－－文档对象模型</h2></header><div class=entry-content><p>DOM中文名文档对象模型，英文名Document Object Model，我们简称为DOM，是针对html和xml文档的一种API，将html以一种树状结构呈现出来，可以更直观去研究文档结构，我们将这种树状文档结构称为－－DOM树，或者节点树，一样的概念
一、什么是DOM？ DOM中文名文档对象模型，英文名Document Object Model，我们简称为DOM，是针对html和xml文档的一种API，将html以一种树状结构呈现出来，可以更直观去研究文档结构，我们将这种树状文档结构称为－－DOM树，或者节点树，一样的概念
js通过dom节点，可以对文档的html标签，属性，css样式，以及具体的内容做出修改，并对页面中的所有事件进行响应
二、节点树 1.节点类型 文档节点－－Document 标签节点－－Element 文本节点－－Text 注释节点－－Comment 属性节点－－Attr 2. 属性 节点类型－－nodeType 节点名称－－nodeName 节点值－－nodeValue 子节点－－childNodes 父节点－－parentNodes 上一个节点－－previousSibling 下一个节点－－nextSibling 第一个子节点－－firstChild 最后一个子节点－－lastChild 3.文档节点－－document (1) 获取 getElementById()－－通过id获取元素 &lt;div id="demo">通过id获取元素&lt;/div> &lt;script> var demo = document.getElementById('demo'); demo.onclick = function() { console.log('通过id获取元素') } &lt;/script> &lt;!-- 点击id为demo的元素，控制台输出'通过id获取元素' --> getElementsByName()－－通过name获取元素 &lt;input type="text" name="int" value="通过name获取元素1"> &lt;input type="text" name="int" value="通过name获取元素2"> &lt;script> var int = document.getElementsByName('int'); for(var i = 0;i &lt; int.length; i++) { console.log(int[i].value); } &lt;/script> &lt;!...</p></div><footer class=entry-footer><span title='2020-11-15 12:58:00 +0000 UTC'>November 15, 2020</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;772 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DOM－－文档对象模型" href=https://zburu-hugo.vercel.app/posts/20201115/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>有关js函数，方法的一些补充总结</h2></header><div class=entry-content><p>数据类型，构造函数，原型和原型链的一些讲解补充
一、数据类型 1.5个基本类型 string number boolean undefined 未定义 null 值为空 symbol 表示一个符号，符号类型是唯一的并且是不可修改的
最常见的还是前三种，字符串，数字，布尔值
2.常见的引用类型 引用类型是一种数据结构，用于将数据和功能组织在一起
对象－Object, 数组－Array, 函数－Function, 正则－RegExp, 日期－Date等
二、函数 1.什么是函数？ 具有独立功能的代码块，在js中使用function关键字定义函数 让代码结构更加清晰，提高代码可用性 js函数的分类：自定义函数和系统函数 2.自定义函数 有一种匿名函数，没有名字的函数，创建闭包，避免造成全局变量的污染
匿名自执行函数
概念：匿名函数的定义完成后立即执行，执行函数表达式 作用：实现闭包和创建独立的命名空间 使用：分组操作符()，void操作符，~操作符，!操作符等等 使用场景：函数表达式，对象属性，事件，事件参数，返回值 定义完匿名函数后，一定要调用 // 函数表达式 window.onload = function() { let funcobj = function() { alert("函数表达式中的匿名函数") } funcobj(); } // 对象属性 window.onload = function() { let obj = { name: function() { alert('对象属性中的匿名函数') } } obj.name(); } 3.内置函数 放在全局下面叫做函数，放在对象里面被叫做方法，对象的方法
常规函数 alert() // 弹出框 confirm() // 弹出一个确认框 prompt() // 弹出一个输入框 isNaN() // 判断是否为数字 parseInt() // 将字符串或浮点数转换为整数 parseFloat() // 将字符串转换为整数或浮点数 eval() // 计算表达式的结果 数组函数 用for循环遍历数组...</p></div><footer class=entry-footer><span title='2020-11-14 12:57:00 +0000 UTC'>November 14, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;465 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 有关js函数，方法的一些补充总结" href=https://zburu-hugo.vercel.app/posts/20201114/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>为什么getTime()返回1970年至今的毫秒？</h2></header><div class=entry-content><p>今天在写new Date()时候，无意中发现了一个很有意思的方法，getTime()，百度了一下，有人说是计算从1970年1月1日至今的毫秒数
为什么要是1970年呢？
new Date().getTime(); // xxxxxxxxxxx 这个起源于unix的诞生，因为Unix在1969年被开发出来，1971年正式发布，在这之前没有机器会需要来表示1970-01-01-00:00:00之前的时间，后面的语言很多就沿用了这一习惯，js只是也沿用了这种习惯而已。
当然，这一做法现在看来是很有问题的，例如不方便用它表示更早的时间而且精度有限。
定义time从1970年1月1日开始，忽然想到在JAVA里，Oracle数据库时间也是从1970年1月1日开始计算。
比如java类代码:
Date date = new Date(0); System.out.println(date); // 打印出来的结果：Thu Jan 01 08:00:00 CST 1970也 是1970年1月1日，实际上时分秒是0点0分0秒(这里打印出来是8点，稍后会作解释)。
为什么这个时间会定义在1970年1月1日这个时候呢?
于是开始了Google，中文网页根本找不到答案。于是试着搜索英文关键字,在Sun java论坛总算找到准确的帖子:
http://forums.sun.com/thread.jspa?threadID=595140&start=15
其中有一个回复:
I suspect that Java was born and raised on a UNIX system. UNIX considers the epoch (when did time begin) to be midnight, January 1, 1970. 是说java起源于UNIX系统，而UNIX认为1970年1月1日0点是时间纪元.
但这依然没很好的解释"为什么",出于好奇，继续Google，总算找到了答案:
http://en.wikipedia.org/wiki/Unix_time
这里的解释是:
最初计算机操作系统是32位，而时间也是用32位表示。
System.out.println(Integer.MAX_VALUE);
2147483647
Integer在JAVA内用32位表示，因此32位能表示的最大值是2147483647。另外1年365天的总秒数是31536000，2147483647/31536000 = 68.1,也就是说32位能表示的最长时间是68年，而实际上到2038年01月19日03时14分07秒，便会到达最大时间，过了这个时间点，所有32位操作系统时间便会变为10000000 00000000 00000000 00000000也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多软件便会运行异常了。
到这里，我想问题的答案已经出来了:...</p></div><footer class=entry-footer><span title='2020-11-13 12:56:00 +0000 UTC'>November 13, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;76 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 为什么getTime()返回1970年至今的毫秒？" href=https://zburu-hugo.vercel.app/posts/20201113/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>面向对象编程</h2></header><div class=entry-content><p>面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
一、什么是面向对象编程 js是基于原型的，基于面向对象编程
面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类
1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。
自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用
面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。
2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统
面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
想要弄明白面向对象，需要先理解类和对象的概念
《什么是类和对象？》
二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = '小明'; person.age = 22; person.year = function() { console.log(this.name + '今年' + this.age + '岁了！') }; person.year(); // 字面量 var student = { name: '小明', age: 22, year: function () { console.log(this.name + '今年' + this.age + '岁了！') } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出： 缺点：重复实例化对象，代码冗余高...</p></div><footer class=entry-footer><span title='2020-11-12 12:58:00 +0000 UTC'>November 12, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;900 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 面向对象编程" href=https://zburu-hugo.vercel.app/posts/20201112/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>小张厨房日记（更新中...）</h2></header><div class=entry-content><p>厨房日记，记录我的’高光’时刻
今日菜谱
莴笋炒肉 准备食材：两根莴笋，一块猪肉，两只青椒
调料：盐，酱油，醋，油，料酒，姜，蒜
炒菜前10分钟将猪肉从冰箱取出，放进碗中，用水浸解冻 将莴笋削皮洗净，用刀切成片状 将浸泡解冻好的猪肉取出，切成肉丁 切少许姜和蒜 准备好两根干辣椒 往锅中倒入一勺油，待至烧熟后，将姜和蒜倒入翻炒 将猪肉倒入锅中大火爆炒，并倒入少许料酒和酱油 一到两分钟过后，将莴笋倒入锅中，并添至少许清水防止太干 翻炒时倒入少许醋，盐，并放入干辣椒， 翻炒防止糊锅，静置等待菜熟 没有很复杂的过程，只是细心就可以做出让自己感受舒心的菜
（更新2020.11.10）
萝卜炖牛肉 准备食材：一根萝卜，四根胡萝卜，一大块牛肉，一卷粉丝
调料：盐，酱油，醋，油，料酒，姜，蒜，胡椒，八角
将牛肉从冰箱取出，切成两块，取一碗清水，然后放在水中化冻 牛肉解冻十分钟左右取出，均匀切碎，根据自己口感可随意 切半块姜，半个蒜，起锅烧油，下葱姜蒜， 暂时没有小葱，等下次有了在下
加入三四片干辣椒，少许胡椒，八角， 等到锅中调料榨出香味，下牛肉，翻炒均匀防止糊锅 倒入料酒，酱油 在翻炒的过程中，用炖锅烧半锅清水，2-3分钟后，将烧锅内牛肉、配料全部倒入炖锅，用勺子翻滚均匀 用盖子盖住 将萝卜切成片，稍微有点厚度的那种，不薄也不厚，6-7分钟左右，下萝卜，并加入适当的盐 下稍加翻滚，盖住盖子，留一个缝隙 在这个期间洗净胡萝卜，去皮，切成块，等到烧锅20分钟左右，下胡萝卜和粉丝 为什么要这么晚才下胡萝卜和粉丝呢？ 因为他俩比较软，熟得快，如果放在锅中时间过长，很容易煮烂
继续煮至30分钟左右，煮的差不多了，尝一下咸淡，可适当加入调料 放一会就可以出锅啦 这是一道耗时比较长的菜，可以慢慢做，大致是这些流程，具体的可根据实际情况调整，比如加入的配菜不同</p></div><footer class=entry-footer><span title='2020-11-09 21:13:00 +0000 UTC'>November 9, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;37 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 小张厨房日记（更新中...）" href=https://zburu-hugo.vercel.app/posts/20201109/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://zburu-hugo.vercel.app/categories/%E6%8A%80%E6%9C%AF/page/8/>« Prev</a>
<a class=next href=https://zburu-hugo.vercel.app/categories/%E6%8A%80%E6%9C%AF/page/10/>Next »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://zburu-hugo.vercel.app>不如吃茶去</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>